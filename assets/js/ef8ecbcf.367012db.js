"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[2515],{35458:(e,n,t)=>{t.d(n,{Ay:()=>c,RM:()=>a});var r=t(74848),i=t(28453),s=t(19365),o=t(11470);const a=[{value:"To be used on its own",id:"to-be-used-on-its-own",level:3},{value:"with spring-boot-starter",id:"with-spring-boot-starter",level:3},{value:"Use plugins provided by the community",id:"use-plugins-provided-by-the-community",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Jimmer itself is technology-neutral, i.e. you can integrate it with any other framework, in addition to providing a quick configuration of the Jimmer Spring boot starter."}),"\n",(0,r.jsx)(n.p,{children:"In this article, you will learn to use Jimmer alone, or take Jimmer starter, you can also adopt the community provided plug-ins."}),"\n",(0,r.jsx)(n.h3,{id:"to-be-used-on-its-own",children:"To be used on its own"}),"\n",(0,r.jsxs)(o.A,{groupId:"buildTool",children:[(0,r.jsx)(s.A,{value:"java_maven",label:"Java(Maven)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",metastring:'title="pom.xml"',children:"<dependencies>\n    \x3c!-- highlight-start --\x3e\n    <dependency>\n        <groupId>org.babyfish.jimmer</groupId>\n        <artifactId>jimmer-sql</artifactId>\n        <version>${jimmer.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.babyfish.jimmer</groupId>\n        <artifactId>jimmer-apt</artifactId>\n        <version>${jimmer.version}</version>\n    </dependency>\n    \x3c!-- highlight-end --\x3e\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.10.1</version>\n            <configuration>\n                <annotationProcessorPaths>\n                    \x3c!-- If you are using lombok, you need to make sure you add this before the jimmer apt --\x3e\n                    \x3c!-- <path>\n                        <groupId>org.projectlombok</groupId>\n                        <artifactId>lombok</artifactId>\n                        <version>${lombok.version}</version>\n                    </path> --\x3e\n\n                    \x3c!-- highlight-start --\x3e\n                    <path>\n                        <groupId>org.babyfish.jimmer</groupId>\n                        <artifactId>jimmer-apt</artifactId>\n                        <version>${jimmer.version}</version>\n                    </path>\n                    \x3c!-- highlight-end --\x3e\n                </annotationProcessorPaths>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n"})})}),(0,r.jsx)(s.A,{value:"java_gradle",label:"Java(Gradle)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kts",metastring:'title="build.gradle.kts"',children:'dependencies {\n    // if use lombok\n    // annotationProcessor("org.projectlombok:lombok:${lombokVersion}")\n    \x3c!-- highlight-start --\x3e\n    implementation("org.babyfish.jimmer:jimmer-sql:${jimmerVersion}")\n    annotationProcessor("org.babyfish.jimmer:jimmer-apt:${jimmerVersion}")\n    \x3c!-- highlight-end --\x3e\n}\n'})})}),(0,r.jsx)(s.A,{value:"kotlin_gradle",label:"Kotlin(Gradle)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",metastring:'title="build.gradle.kts"',children:'plugins {\n    kotlin("jvm") version "2.1.0"\n    // ksp\n    id("com.google.devtools.ksp") version "2.1.0-1.0.29"\n}\n\nval jimmerVersion = "0.9.45"\n\ndependencies {\n    // ksp\n    ksp("org.babyfish.jimmer:jimmer-ksp:${jimmerVersion}")\n    // Jimmer sql for kotlin\n    implementation("org.babyfish.jimmer:jimmer-sql-kotlin:${jimmerVersion}")\n}\n\n// Add generated code to compile path.\n// Gradle build works without this, but IntelliJ won\'t find generated code. \nkotlin {\n    sourceSets.main {\n        kotlin.srcDir("build/generated/ksp/main/kotlin")\n    }\n}\n'})})})]}),"\n",(0,r.jsx)(n.h3,{id:"with-spring-boot-starter",children:"with spring-boot-starter"}),"\n",(0,r.jsxs)(o.A,{groupId:"buildTool",children:[(0,r.jsx)(s.A,{value:"java_maven",label:"Java(Maven)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",metastring:'title="pom.xml"',children:"<dependencies>\n    <dependency>\n        <groupId>org.babyfish.jimmer</groupId>\n        <artifactId>jimmer-spring-boot-starter</artifactId>\n        <version>${jimmer.version}</version>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <annotationProcessorPaths>\n                    \x3c!-- If you are using lombok, you need to make sure you add this before the jimmer apt --\x3e\n                    \x3c!-- <path>\n                        <groupId>org.projectlombok</groupId>\n                        <artifactId>lombok</artifactId>\n                        <version>${lombok.version}</version>\n                    </path> --\x3e\n\n                    <path>\n                        <groupId>org.babyfish.jimmer</groupId>\n                        <artifactId>jimmer-apt</artifactId>\n                        <version>${jimmer.version}</version>\n                    </path>\n                </annotationProcessorPaths>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n"})})}),(0,r.jsx)(s.A,{value:"java_gradle",label:"Java(Gradle)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-groovy",metastring:'title="build.gradle"',children:'dependencies {\n    ...omitted other dependencies...\n    annotationProcessor "org.babyfish.jimmer:jimmer-apt:${jimmerVersion}"\n    implementation "org.babyfish.jimmer:jimmer-spring-boot-starter:${jimmerVersion}"\n}\n'})})}),(0,r.jsx)(s.A,{value:"kotlin_gradle",label:"Kotlin(Gradle.kts)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",metastring:'title="build.gradle.kts"',children:'plugins {\n    // use ksp plugin\n    id("com.google.devtools.ksp") version "1.7.10-1.0.6"\n\n    ...omitted other dependencies...\n}\ndependencies {\n    implementation("org.babyfish.jimmer:jimmer-spring-boot-starter:${jimmerVersion}")\n    // use jimmer ksp\n    // highlight-next-line\n    ksp("org.babyfish.jimmer:jimmer-ksp:${jimmerVersion}")\n\n    ...omitted other dependencies...\n}\n\n// Add generated code to compile path.\n// Gradle build works without this, but IntelliJ won\'t find generated code. \nkotlin {\n    sourceSets.main {\n        kotlin.srcDir("build/generated/ksp/main/kotlin")\n    }\n}\n'})})})]}),"\n",(0,r.jsxs)(n.admonition,{type:"important",children:[(0,r.jsxs)(n.p,{children:["Java projects are often used in conjunction with Lombok. By default, if the project has no other APTs besides lombok, it is sufficient to import the lombok dependencies. However, once other APT configurations are introduced ",(0,r.jsx)(n.em,{children:"(not necessarily Jimmer's APT, it can be any other APT)"}),", ",(0,r.jsx)(n.strong,{children:"then lombok's APT must be explicitly configured, and lombok's APT must come before Jimmer's in Maven."})]}),(0,r.jsx)(n.p,{children:"There is no need to declare Jimmer's APT if the community-provided Gradle plugin is used (see below)."})]}),"\n",(0,r.jsx)(n.h3,{id:"use-plugins-provided-by-the-community",children:"Use plugins provided by the community"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.a,{href:"https://github.com/ArgonarioD/gradle-plugin-jimmer",children:"https://github.com/ArgonarioD/gradle-plugin-jimmer"})}),(0,r.jsxs)(o.A,{children:[(0,r.jsx)(s.A,{value:"java_gradle",label:"Java (Gradle Plugin)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-groovy",metastring:'title="build.gradle"',children:'plugins {\n    // Starting from Gradle 7.0, you can use "latest.release" instead of a specific version number to represent the use of the latest version.\n    // You can also use the \'+\' character to indicate matching the latest version number starting from the \'+\' character.\n    id "tech.argonariod.gradle-plugin-jimmer" version "latest.release"\n\n    ...other plugins omitted...\n}\n\njimmer {\n    // Set the Jimmer dependency version, where you can also use version range expressions such as "latest.release" or "0.+"\n    version = "${jimmerVersion}"\n}\n'})})}),(0,r.jsx)(s.A,{value:"kotlin_gradle",label:"Kotlin (Gradle Plugin)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",metastring:'title="build.gradle.kts"',children:'plugins {\n    // Starting from Gradle 7.0, you can use "latest.release" instead of a specific version number to represent the use of the latest version.\n    id("tech.argonariod.gradle-plugin-jimmer") version "latest.release"\n    // You can also use the \'+\' character to indicate matching the latest version number starting from the \'+\' character.\n    // Add KSP plugin\n    id("com.google.devtools.ksp") version "1.7.10+"\n\n    ...other plugins omitted...\n}\n\njimmer {\n    // Set the Jimmer dependency version, where you can also use version range expressions such as "latest.release" or "0.+"\n    version = "${jimmerVersion}"\n}\n'})})})]})]}),"\n","\n",(0,r.jsxs)(n.admonition,{type:"note",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://kotlinlang.org/docs/ksp-overview.html",children:"KSP"})," only supports gradle,\nIt has been proven that KSP's third-party Maven plug-in support cannot keep up with the version\niteration of 'kotlin/KSP' itself, and often encounters many problems during the upgrade process."]}),(0,r.jsx)(n.p,{children:"Eventually, Jimmer dropped Maven support for Kotlin and asked Kotlin developers to use Gradle."})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},87143:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"overview/apt-ksp","title":"APT/KSP","description":"Basic Concepts","source":"@site/docs/overview/apt-ksp.mdx","sourceDirName":"overview","slug":"/overview/apt-ksp","permalink":"/jimmer-doc/docs/overview/apt-ksp","draft":false,"unlisted":false,"editUrl":"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/overview/apt-ksp.mdx","tags":[],"version":"current","lastUpdatedAt":1736821821000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"APT/KSP"},"sidebar":"tutorialSidebar","previous":{"title":"Overview \u2726","permalink":"/jimmer-doc/docs/overview/introduction"},"next":{"title":"How To Use","permalink":"/jimmer-doc/docs/overview/how-to-use"}}');var i=t(74848),s=t(28453);t(19365),t(11470),t(35458);const o={sidebar_position:4,title:"APT/KSP"},a=void 0,l={},c=[{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Notes",id:"notes",level:2},{value:"Two Styles of Java Code",id:"two-styles-of-java-code",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"basic-concepts",children:"Basic Concepts"}),"\n",(0,i.jsx)(n.p,{children:"Jimmer heavily relies on the precompilation technology in the JVM ecosystem:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For Java, it's ",(0,i.jsx)(n.code,{children:"APT"}),", i.e., ",(0,i.jsx)(n.a,{href:"https://www.jetbrains.com/help/idea/annotation-processors-support.html",children:"Annotation Processor Tool"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For Kotlin, it's ",(0,i.jsx)(n.code,{children:"KSP"}),", i.e., ",(0,i.jsx)(n.a,{href:"https://kotlinlang.org/docs/ksp-overview.html",children:"Kotlin Symbol Processing"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"Some code generated by APT/KSP is necessary for using Jimmer."}),(0,i.jsxs)(n.p,{children:["Therefore, if you open any Java/Kotlin project from the ",(0,i.jsx)(n.a,{href:"https://github.com/babyfish-ct/jimmer-examples",children:"official examples"})," in IntelliJ, you will find that some code that should have been automatically generated is missing. For this, you can choose any of the following methods:"]}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["First, execute the ",(0,i.jsx)(n.code,{children:"./mvnw install"})," ",(0,i.jsx)(n.em,{children:"(for Java examples only)"})," or ",(0,i.jsx)(n.code,{children:"./gradlew build"})," command in the directory of the project you want to open from the command line to complete the code generation, then open the project with IntelliJ."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Open the project directly with IntelliJ, ignore the IDE errors temporarily, and after the dependencies are downloaded, run the project's main method or unit test ",(0,i.jsx)(n.em,{children:"(save-command/save-command-kt demonstrates features using unit tests)"}),". All IDE errors will automatically disappear, and the application will start correctly."]}),"\n"]}),"\n"]})]}),"\n",(0,i.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(n.p,{children:["Since Jimmer is a compile-time framework, and considering that not all users are familiar with ",(0,i.jsx)(n.code,{children:"apt"})," and ",(0,i.jsx)(n.code,{children:"ksp"}),", it's necessary to mention an important detail."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Apt/Ksp"})," are standard technologies in the industry, and Java IDEs provide support for them."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["In most cases, your modifications will include changes to Java or Kotlin code, such as changes in entity types or Web Controller*(Jimmer has its own implementations for OpenAPI and TypeScript generation)*. In this case, you only need to click the IDE's ",(0,i.jsx)(n.code,{children:"Run"})," or ",(0,i.jsx)(n.code,{children:"Debug"})," button once, without requiring a full compilation, to trigger all pre-compilation behaviors, the automatically generated source code and resource files will update automatically."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"In rare cases, if you only modify DTO files, meaning there are no Java or Kotlin source code changes within the same project except for the DTO files, you have three options:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use the companion DTO plugin"}),"\n",(0,i.jsxs)(n.li,{children:["Perform a full compilation using maven or gradle commands, or the IDE's ",(0,i.jsx)(n.code,{children:"Rebuild"})," button, which can achieve this purpose"]}),"\n",(0,i.jsxs)(n.li,{children:["Delete the affected project's compilation output directory, then click the IDE's ",(0,i.jsx)(n.code,{children:"Run"})," or ",(0,i.jsx)(n.code,{children:"Debug"})," button`"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"two-styles-of-java-code",children:"Two Styles of Java Code"}),"\n",(0,i.jsx)(n.p,{children:"Unlike the Kotlin API, the Java API cannot avoid to directly use automatically generate types in user code. Let's compare the following:"}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("thead",{children:[(0,i.jsx)("th",{children:"Feature"}),(0,i.jsx)("th",{children:"Java"}),(0,i.jsx)("th",{children:"Kotlin"})]}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{rowspan:"2",children:"Draft"}),(0,i.jsxs)("td",{children:["Use the generated type ",(0,i.jsx)(n.code,{children:"BookDraft"})]}),(0,i.jsxs)("td",{children:["Use the original entity type ",(0,i.jsx)(n.code,{children:"Book"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Book book = \n    // highlight-next-line\n    BookDraft.$.produce(b -> {\n        b.setName("SQL");\n        b.addIntoAuthors(a -> {\n            a.setName("Jessica");\n        });\n        b.addIntoAuthors(a -> {\n            a.setName("Bob");\n        });\n    });\n'})})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'val book =\n    // highlight-next-line\n    Book {\n        name = "SQL in Action"\n        authors().addBy {\n            name = "Jessica"\n        }\n        authors().addBy {\n            name = "Bob"\n        }\n    }\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{rowspan:"2",children:"SQL DSL"}),(0,i.jsxs)("td",{children:["Use the generated type ",(0,i.jsx)(n.code,{children:"BookTable"})]}),(0,i.jsxs)("td",{children:["Use the original entity type ",(0,i.jsx)(n.code,{children:"Book"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// highlight-next-line\nBookTable table = BookTable.$;\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(table.storeId().isNull())\n    .orderBy(table.name())\n    .select(table)\n    .execute();\n"})})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"List<Book> books = sqlClient\n    // highlight-next-line\n    .createQuery(Book::class) {\n        where(table.storeId.isNull())\n        orderBy(table.name)\n        select(table)\n    }\n    .execute()\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{rowspan:"2",children:"Fetcher"}),(0,i.jsxs)("td",{children:["Use the generated types ",(0,i.jsx)(n.code,{children:"BookFetcher"}),", ",(0,i.jsx)(n.code,{children:"BookStoreFetcher"}),", and ",(0,i.jsx)(n.code,{children:"AuthorFetcher"})]}),(0,i.jsxs)("td",{children:["Use the original entity type ",(0,i.jsx)(n.code,{children:"Book"})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"Fetcher<Book> fetcher =\n    // highlight-next-line\n    BookFetcher.$\n        .allScalarFields()\n        .store(\n            // highlight-next-line\n            BookStoreFetcher.$\n                .allScalarFields()\n        )\n        .authors(\n            // highlight-next-line\n            AuthorFetcher.$\n                .allScalarFields()\n        )\n"})})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val fetcher = \n    // highlight-next-line\n    newFetcher(Book::class).by {\n        allScalarFields()\n        store {\n            allScalarFields()\n        }\n        authors {\n            allScalarFields()\n        }\n    }\n"})})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"As you can see, the abstraction capabilities of Java and Kotlin are different, resulting in different effects that the API design can achieve:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For Kotlin, regardless of the scenario, you only need to use the original entity type ",(0,i.jsx)(n.code,{children:"Book"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["For Java, you have to use the types automatically generated by the Annotation Processor, such as ",(0,i.jsx)(n.code,{children:"BookDraft"}),", ",(0,i.jsx)(n.code,{children:"BookTable"}),", ",(0,i.jsx)(n.code,{children:"BookFetcher"}),", etc."]}),"\n",(0,i.jsxs)(n.p,{children:["In the above Java code, ",(0,i.jsx)(n.code,{children:".$"})," appears frequently, ",(0,i.jsx)(n.code,{children:"$"})," are static read-only fields of these classes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Actually, using ",(0,i.jsx)(n.code,{children:"$"})," is the simplest way. However, considering that some Java developers have subjective biases against ",(0,i.jsx)(n.code,{children:"$"}),", for Java subprojects defining entity types, Jimmer's APT also generate four summary types:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Objects"})," class"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Tables"})," interface"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"TableExes"})," interface"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Fetchers"})," interface"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The package where these four types reside is the common package for all entities."}),"\n",(0,i.jsx)(n.p,{children:"These four types provide another coding style for Java code by defining static constants, and the two styles are compared as follows:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.th,{children:["Style Accepting ",(0,i.jsx)(n.code,{children:"$"})]}),(0,i.jsxs)(n.th,{children:["Style Not Accepting ",(0,i.jsx)(n.code,{children:"$"})]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BookDraft.$.produce"}),(0,i.jsx)(n.td,{children:"Immutables.createBook"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BookTable.$"}),(0,i.jsx)(n.td,{children:"Tables.BOOK_TABLE"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BookTableEx.$"}),(0,i.jsx)(n.td,{children:"TableExes.BOOK_TABLE_EX"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"BookFetcher.$"}),(0,i.jsx)(n.td,{children:"Fetchers.BOOK_FETCHER"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, ",(0,i.jsx)(n.code,{children:"Tables"}),", ",(0,i.jsx)(n.code,{children:"TableExes"}),", and ",(0,i.jsx)(n.code,{children:"Fetchers"})," are interfaces, and you can use the ",(0,i.jsx)(n.code,{children:"implements"})," statement to further simplify the code ",(0,i.jsx)(n.em,{children:"(since IntelliJ does not support static imports well, implementing interfaces that define constants is still a recommended technique)"}),". For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public interface FetcherConstants\n// highlight-next-line\nimplements Fetchers {\n    \n    Fetcher<Book> BOOK_DETAIL_FETCHER =\n        BOOK_FETCHER\n            .allScalarFields()\n            .store(\n                BOOK_STORE_FETCHER\n                    .allScalarFields()\n            )\n            .authors {\n                AUTHOR_FETCHER\n                    .allScalarFields()\n            };\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},19365:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var r=t(34164);const i={tabItem:"tabItem_Ymn6"};var s=t(74848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,o),hidden:t,children:n})}},11470:(e,n,t)=>{t.d(n,{A:()=>k});var r=t(96540),i=t(34164),s=t(23104),o=t(56347),a=t(205),l=t(57485),c=t(31682),d=t(70679);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:i}}=e;return{value:n,label:t,attributes:r,default:i}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const i=(0,o.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,l.aZ)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(i.location.search);n.set(s,e),i.replace({...i.location,search:n.toString()})}),[s,i])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:i}=e,s=u(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[c,h]=p({queryString:t,groupId:i}),[g,j]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,s]=(0,d.Dv)(t);return[i,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:i}),x=(()=>{const e=c??g;return m({value:e,tabValues:s})?e:null})();(0,a.A)((()=>{x&&l(x)}),[x]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),j(e)}),[h,j,s]),tabValues:s}}var j=t(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=t(74848);function f(e){let{className:n,block:t,selectedValue:r,selectValue:o,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{const n=e.currentTarget,t=l.indexOf(n),i=a[t].value;i!==r&&(c(n),o(i))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=l.indexOf(e.currentTarget)+1;n=l[t]??l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=l[t]??l[l.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},n),children:a.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>l.push(e),onKeyDown:h,onClick:d,...s,className:(0,i.A)("tabs__item",x.tabItem,s?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:s}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function y(e){const n=g(e);return(0,b.jsxs)("div",{className:(0,i.A)("tabs-container",x.tabList),children:[(0,b.jsx)(f,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function k(e){const n=(0,j.A)();return(0,b.jsx)(y,{...e,children:h(e.children)},String(n))}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);