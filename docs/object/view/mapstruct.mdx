---
sidebar_position: 2
title: MapStruct
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { ShortAssociation } from '@site/src/components/ShortAssociation';
import { ViewMore } from '@site/src/components/ViewMore';
import { VersionBadgeAdmonition } from '@site/src/components/VersionBadgeAdmonition';

## Introduction

Jimmer extends [MapStruct](https://mapstruct.org/) to support using mapstruct to complete the mutual conversion between Jimmer dynamic entity objects and static DTO objects.

### Notes

Jimmer's entity objects are dynamic *(similar to scalar attribute lazy loading introduced in Hibernate 3)*, which is a pattern that earlier versions of [MapStruct](https://mapstruct.org/) did not consider.

After communicating with [MapStruct](https://mapstruct.org/), [MapStruct](https://mapstruct.org/) will support this behavior starting from `1.6.0`. 

:::caution
Therefore, please use `1.6.0` or higher version of [MapStruct](https://mapstruct.org/) whenever possible.
:::

### Advantages

-   Unlike [DTO Language](./dto-language) which pursues fast development but supports fixed conversion logic, [mapstruct](https://mapstruct.org/) can implement arbitrarily complex conversion logic.

-   Unlike [DTO Language](./dto-language) which directly generates brand new DTO types, [mapstruct](https://mapstruct.org/) can integrate existing DTO types.

### Disadvantages  

[DTO Language](./dto-language) is more recommended for the following reasons:

-   Non-negligible development costs

    [DTO Language](./dto-language) is a solution tailored for Jimmer with development efficiency that cannot be compared when combined with any other technical solutions.

-   Not very suitable for Output DTO

    The DTO types automatically generated by the DTO language have built-in [Object Fetchers](../../query/object-fetcher), so they can be used as query output types *(although not recommended)*, please refer to:

    -   [Object Fetcher/DTO Query](../../query/object-fetcher/dto)

    -   [Spring Data/Query DTO](../../spring/repository/dto)

    However, manually defined DTO types do not have corresponding [Object Fetcher](../../query/object-fetcher) definitions, and only support mutual conversion with dynamic entities.
    Although [Object Fetchers](../../query/object-fetcher) can be manually defined for this, there is a risk that the DTO and [Object Fetcher](../../query/object-fetcher) shapes will be inconsistent.
    So it is not suitable as Output DTO.

-   Kotlin risks

    -   [mapstruct](https://mapstruct.org/) is based on `apt` *(Annotation Processor)*.

        Therefore, this requires using `kapt` in Kotlin, which will significantly reduce the compilation speed of Kotlin projects.

    -   Kotlin has deprecated [kapt](https://kotlinlang.org/docs/kapt.html) in favor of [ksp](https://kotlinlang.org/docs/ksp-overview.html). 

        Therefore, using `kapt` may encounter problems in the future as Kotlin evolves.

## Dependencies and Preprocessors

For converting static POJOs to Jimmer dynamic objects, MapStruct does not know how to build Jimmer objects. So

-   Jimmer's own preprocessor *(Java's `jimmer-apt` or Kotlin's `jimmer-ksp`)* generates some MapStruct-oriented code in Draft, allowing MapStruct to build Jimmer objects through its [Builder](https://mapstruct.org/documentation/stable/reference/html/#mapping-with-builders) mode.

-   Jimmer extends MapStruct's Annotation Processor. This extension allows MapStruct to utilize the capabilities reserved for MapStruct in the generated Draft to build Jimmer objects.

    This extension is called `jimmer-mapstruct-apt`

    -   For Java, `jimmer-mapstruct-apt` is included in `jimmer-apt`

    -   For Kotlin, `jimmer-ksp` and `jimmer-mapstruct-apt` must be used together in the maven or gradle configuration file. 

You can use either Jimmer's standard build method, or use plugins provided by the community.

-   Method 1: Use Jimmer's standard build method

    <VersionBadgeAdmonition />

    <Tabs groupId="buildTool">
    <TabItem value="java_maven" label="Java(Maven)">

    ```xml title="pom.xml"
    ...omit other code...

    <build>
        <dependencies>
            <dependency> ➀
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </dependency>
            <dependency> ➊
                <groupId>org.mapstruct</groupId>
                <artifactId>mapstruct</artifactId>
                <version>${mapstruct.version}</version>
            </dependency>
            ...omit other dependencies...
        </dependencies>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path> ➁
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path> ➋
                            <groupId>org.babyfish.jimmer</groupId>
                            <artifactId>jimmer-apt</artifactId>
                            <version>${jimmer.version}</version>
                        </path>
                        <path> ➌
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

    ...omit other code...
    ```

    </TabItem>
    <TabItem value="java_gradle" label="Java(Gradle)">

    ```groovy title="build.gradle"
    dependencies {

        implementation "org.projectlombok:lombok:${lombok.version}" ➀
        implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

        annotationProcessor "org.projectlombok:lombok:${lombok.version}" ➁
        annotationProcessor "org.babyfish.jimmer:jimmer-apt:${jimmerVersion}" ➋
        annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}" ➌

        ...omit other dependencies...
    }
    ```

    </TabItem>
    <TabItem value="kotlin_gradle" label="Kotlin(Gradle.kts)">

    ```kotlin title="build.gradle.kts"
    plugins {
        id("com.google.devtools.ksp") version "1.7.10-1.0.6"
        kotlin("kapt") version "1.7.10"

        ...omit other plugins...
    }

    dependencies {

        implementation("org.mapstruct:mapstruct:${mapstructVersion}") ➊

        ksp("org.babyfish.jimmer:jimmer-ksp:${jimmerVersion}") ➋
        kapt("org.mapstruct:mapstruct-processor:${mapstructVersion}") ➌
        kapt("org.babyfish.jimmer:jimmer-mapstruct-apt:${jimmerVersion}") ⓐ

        ...omit other dependencies...
    }

    kotlin {
        sourceSets.main {
            kotlin.srcDir("build/generated/ksp/main/kotlin")
        }
    }
    ```

    </TabItem>
    </Tabs>

-   Method 2: Use plugins provided by the community

    <details>
    <summary>https://github.com/ArgonarioD/gradle-plugin-jimmer</summary>
    <Tabs>
    <TabItem value="java_gradle" label="Java(Gradle Plugin)">

    ```groovy title="build.gradle"
    plugins {
        id "tech.argonariod.gradle-plugin-jimmer" version "latest.release"

        ...omit other plugins...
    }

    jimmer {
        version = "${jimmerVersion}"

        ...omit other configurations...
    }

    dependencies {

        implementation "org.projectlombok:lombok:${lombok.version}" ➀
        implementation "org.mapstruct:mapstruct:${mapstructVersion}" ➊

        annotationProcessor "org.projectlombok:lombok:${lombok.version}" ➁
        annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}" ➍

        // there's no need to add org.babyfish.jimmer:jimmer-apt to dependencies manually
        // when mapstruct-processor dependency is detected，the gradle plugin will add jimmer-apt to dependencies automatically

        ...omit other dependencies...
    }
    ```

    </TabItem>
    <TabItem value="kotlin_gradle" label="Kotlin(Gradle Plugin)">

    ```kotlin title="build.gradle.kts"
    plugins {
        id("tech.argonariod.gradle-plugin-jimmer") version "latest.release"
        id("com.google.devtools.ksp") version "1.7.10+"
        kotlin("kapt") version "1.7.10"

        ...omit other plugins...
    }

    jimmer {
        version = "${jimmerVersion}"

        ...omit other configurations...
    }

    dependencies {

        implementation("org.mapstruct:mapstruct:${mapstructVersion}") ➊
        kapt("org.mapstruct:mapstruct-processor:${mapstructVersion}") ➌

        ...omit other dependencies...
    }
    ```

    :::info
    The plugin will automatically configure it for you when you have the MapStruct kapt dependency.
    :::

    </TabItem>
    </Tabs>
    </details>

    {/* TODO: Insert gradle plugin before this line */}

In this example, we assume static POJOs are written in Java using [lombok](https://projectlombok.org/).

<table>
    <thead>
        <tr>
            <th>Language</th>
            <th>Location</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="3">Java and Kotlin</td>
            <td>➊</td>
            <td>Introduce mapstruct dependency for user code to use mapstruct annotations</td>
        </tr>
        <tr>
            <td>➋</td>
            <td>Use Jimmer's preprocessor to generate related source code for dynamic types, Java uses `jimmer-apt`, Kotlin uses `jimmer-ksp`</td>
        </tr>
        <tr>
            <td>➌</td>
            <td>Use mapstruct's annotation processor to generate source code <i>(introduced later)</i></td>
        </tr>
        <tr>
            <td rowspan="2">Java only</td>
            <td>➀</td>
            <td>Introduce lombok dependency for user code to use lombok annotations</td>
        </tr>
        <tr>
            <td>➁</td>
            <td>Use Lombok preprocessor to modify static POJO class code, e.g. add getters, setters</td>
        </tr>
        <tr>
            <td rowspan="2">Kotlin only</td>
            <td>ⓐ</td>
            <td>Use `jimmer-mapstruct-apt` to extend ➌</td>
        </tr>
    </tbody>
</table>

## Define POJO

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"
@Data
public class BookInput {

    @Nullable
    private Long id;

    private String name;

    private int edition;

    private BigDecimal price;

    @Nullable
    private Long storeId;

    private List<Long> authorIds;
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.java"
data class BookInput(
    val id: Long? = null,
    val name: String,
    val edition: Int,
    val price: BigDecimal,
    val storeId: Long?,
    val authorIds: List<Long>
)
```

</TabItem>
</Tabs>

:::note
The `@Nullable` annotation is used in the Java POJO code only to improve readability and has no functional effect
:::

Three properties of this POJO need to be explained:

-   `BookInput.id`

    - Here, `BookInput.id` is allowed to be null. This is necessary, for example, the id does not need to be specified when inserting data.

    - The dynamic property `Book.id` of the entity object does not allow null *(Jimmer prohibits id from being null, please refer to [Mapping/Basic Mapping/@Id](../../mapping/base/basic#id))*

    The two contradict each other, so how to convert `BookInput` to `Book`?

    :::tip
    Jimmer agrees that if the property of the POJO can be null while the corresponding property of the dynamic object cannot be null, the corresponding property of the dynamic object will not be assigned and will remain missing.
    :::

-   `BookInput.storeId` 

    This is obviously an associated id for the dynamic entity object property `Book.store`. 

    This kind of dynamic object property is defined as an associated object, but in the POJO it is defined as an associated id, 
    called a <ViewMore buttonText="short association"><ShortAssociation/></ViewMore>.

-   `BookInput.authorIds` 

    This is obviously a collection of associated ids, for the dynamic entity object property `Book.authors`. 

    This kind of dynamic object property is defined as an associated objects, but in the POJO it is defined as an associated ids, 
    called a <ViewMore buttonText="short association"><ShortAssociation/></ViewMore>.

The other properties are exactly the same as the original entity definition and need no explanation.

## Define Mapper

The most important thing when using mapstruct is to define the Mapper, as follows

<Tabs groupId="language">
<TabItem value="java" label="Java">  

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    Book toBook(BookInput input);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"  
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    fun toBook(input: BookInput): Book
}
```

</TabItem>
</Tabs>

This Mapper provides a `toBook` method to convert a `BookInput` object to a `Book` object. 

`BookInput.id`, `BookInput.id`, `BookInput.name` and `BookInput.price` are all non-associated properties that mapstruct can handle well.

:::note
The issue that `BookInput.id` can be null while `Book.id` cannot be null has been discussed before, so it won't be repeated here.
:::

The key is how `BookInput.storeId` and `BookInput.authorIds` should be mapped, which falls into two cases:

-   The entity defines @IdView properties  

-   The entity does not define @IdView properties

### If the entity defines @IdView properties

If the entity type defines `@IdView` properties, for example:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="Book.java"
package com.example.model;

import org.babyfish.jimmer.sql.*;
import org.jetbrains.annotations.Nullable;

@Entity
public interface Book {

    ...omit other properties...

    @ManyToOne
    @Nullable
    BookStore store();

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    List<Author> authors();

    // highlight-next-line
    @IdView // id view of associated object store  
    Long storeId();

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors")    
    List<Long> authorIds();
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="Book.kt"
package com.example.model

import org.babyfish.jimmer.sql.*

@Entity
interface Book {

    ...omit other properties...

    @ManyToOne
    val store: BookStore?

    @ManyToMany
    @JoinTable(
        name = "BOOK_AUTHOR_MAPPING",
        joinColumnName = "BOOK_ID",
        inverseJoinColumnName = "AUTHOR_id"
    )
    val authors: List<Author>

    // highlight-next-line
    @IdView // id view of associated object store
    val storeId: Long?

    // id view of all objects in associated collection authors
    // highlight-next-line
    @IdView("authors") 
    val authorIds: List<Long>
}
```

</TabItem>
</Tabs>

In this case, the entity object and POJO correspond completely, and the Mapper does not need any modification.

### If the entity does not define @IdView properties

If the entity type does not define `@IdView` properties, the Mapper needs to be modified:

-   Convert `BookInput.storeId` to a `BookStore` object with only the id, then assign it to `Book.store`

-   Convert `BookInput.authorIds` to a collection of `Author` objects with only ids, then assign it to `Book.authors`

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId") 
    // highlight-next-line
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    BookStore toBookStore(Long id);

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id);
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store", source = "storeId")
    // highlight-next-line 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toBookStore(id: Long?): BookStore

    @BeanMapping(ignoreByDefault = true)
    // highlight-next-line
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

Since mapstruct also supports `@Mapping(target = "store.id", source = "storeId")`, the following syntax can also be used to simplify the code:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInputMapper.java"
@Mapper
public interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line  
    @Mapping(target = "store.id", source = "storeId")
    @Mapping(target = "authors", source = "authorIds")
    Book toBook(BookInput input);

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    Author toAuthor(Long id); 
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInputMapper.java"
@Mapper
interface BookInputMapper {

    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
    // highlight-next-line
    @Mapping(target = "store.id", source = "storeId") 
    @Mapping(target = "authors", source = "authorIds")
    fun toBook(input: BookInput): Book

    @BeanMapping(ignoreByDefault = true)
    @Mapping(target = "id", source = ".")
    fun toAuthor(id: Long?): Author
}
```

</TabItem>
</Tabs>

## Usage

Now we can convert `BookInput` to `Book`:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java
BookInput input = ...omit...;
BookInputMapper mapper = Mappers.getMapper(BookInputMapper.class);
Book book = mapper.toBook(input);
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
val input: BookInput = ...omit...
val mapper = Mappers.getMapper(BookInputMapper::class.java)
val book = mapper.toBook(input)
```

</TabItem>
</Tabs>

## Make POJO implement Input interface

Jimmer provides a simple interface, `org.babyfish.jimmer.Input<E>`

```java
public interface Input<E> {

    E toEntity(); 
}
```

Dynamic objects will never implement this interface, this interface should be implemented by user-defined static POJO classes. Its function is very simple, just convert the current static POJO to a dynamic object.

This interface can provide convenience at the syntax level. Whether it is the underlying [save command](../../mutation/save-command) or the top-level spring-data base interface `JRepository/KRepository`, its `sava` method directly accepts `Input` parameters, without the user having to call the Mapper to complete the conversion.

If you want this convenience at the syntax level, you can choose to have the POJO implement this interface by modifying the `BookInput` code as follows:

<Tabs groupId="language">
<TabItem value="java" label="Java">

```java title="BookInput.java"  
@Data
public class BookInput implements Input<Book> { ❶

    private static final Converter CONVERTER =  
        Mappers.getMapper(Converter.class);

    ...omit private fields...

    @Override  
    public Book toEntity() { ❷
        return CONVERTER.toBook(this);
    }

    @Mapper
    interface Converter {

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        Book toBook(BookInput input);

        ...omit other mapstruct configuration... 
    }
}
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin title="BookInput.kt"
data class BookInput(
    ...omit... 
): Input<Book> { ❶

    override fun toEntity(): Book = ❷
        CONVERTER.toBook(this)

    @Mapper  
    internal interface Converter {  

        @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)
        fun toBook(input: BookInput): Book

        ...omit other mapstruct configuration...
    }

    companion object {

        @JvmStatic  
        private val CONVERTER =   
            Mappers.getMapper(Converter::class.java)  
    }
}
```

</TabItem> 
</Tabs>

-   ❶ `BookInput` class implements interface `org.babyfish.jimmer.Input`

-   ❷ Implement `Input.toEntity` method, use MapStruct to convert the current static `Input DTO` object to the dynamic `Book` entity object. This is the only function of this class.
