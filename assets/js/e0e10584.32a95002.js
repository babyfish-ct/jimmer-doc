"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[698],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,k=d["".concat(s,".").concat(c)]||d[c]||u[c]||o;return n?a.createElement(k,i(i({ref:t},m),{},{components:n})):a.createElement(k,i({ref:t},m))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),r=n(34334);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,i),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(83117),r=n(67294),o=n(34334),i=n(72389),l=n(67392),s=n(7094),p=n(12466);const m="tabList__CuJ",u="tabItem_LNqP";function d(e){var t;const{lazy:n,block:i,defaultValue:d,values:c,groupId:k,className:b}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),h=c??g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),N=(0,l.l)(h,((e,t)=>e.value===t.value));if(N.length>0)throw new Error(`Docusaurus error: Duplicate values "${N.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const y=null===d?d:d??(null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)??g[0].props.value;if(null!==y&&!h.some((e=>e.value===y)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${y}" but none of its children has the corresponding value. Available values are: ${h.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:T}=(0,s.U)(),[x,v]=(0,r.useState)(y),_=[],{blockElementScrollPositionUntilNextRender:B}=(0,p.o5)();if(null!=k){const e=f[k];null!=e&&e!==x&&h.some((t=>t.value===e))&&v(e)}const I=e=>{const t=e.currentTarget,n=_.indexOf(t),a=h[n].value;a!==x&&(B(t),v(a),null!=k&&T(k,String(a)))},S=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=_.indexOf(e.currentTarget)+1;n=_[t]??_[0];break}case"ArrowLeft":{const t=_.indexOf(e.currentTarget)-1;n=_[t]??_[_.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",m)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},b)},h.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===t?0:-1,"aria-selected":x===t,key:t,ref:e=>_.push(e),onKeyDown:S,onFocus:I,onClick:I},i,{className:(0,o.Z)("tabs__item",u,null==i?void 0:i.className,{"tabs__item--active":x===t})}),n??t)}))),n?(0,r.cloneElement)(g.filter((e=>e.props.value===x))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==x})))))}function c(e){const t=(0,i.Z)();return r.createElement(d,(0,a.Z)({key:String(t)},e))}},34746:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>p,toc:()=>u});var a=n(83117),r=(n(67294),n(3905)),o=n(65488),i=n(85162);const l={sidebar_position:3,title:"Complex Queries"},s=void 0,p={unversionedId:"spring/repository/default",id:"spring/repository/default",title:"Complex Queries",description:"In the previous document, we introduced adding abstract methods to custom Repository interfaces following certain conventions, which are implemented automatically by Jimmer.",source:"@site/docs/spring/repository/default.mdx",sourceDirName:"spring/repository",slug:"/spring/repository/default",permalink:"/jimmer-doc/docs/spring/repository/default",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/spring/repository/default.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Complex Queries"},sidebar:"tutorialSidebar",previous:{title:"Simple Queries",permalink:"/jimmer-doc/docs/spring/repository/abstract"},next:{title:"Query DTO",permalink:"/jimmer-doc/docs/spring/repository/dto"}},m={},u=[{value:"Dynamic WHERE",id:"dynamic-where",level:2},{value:"Dynamic JOIN",id:"dynamic-join",level:2},{value:"Subqueries",id:"subqueries",level:2},{value:"Dynamic ORDER BY",id:"dynamic-order-by",level:2},{value:"Pagination",id:"pagination",level:2},{value:"Object Fetcher",id:"object-fetcher",level:2}],d={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"./abstract"},"previous document"),", we introduced adding abstract methods to custom Repository interfaces following certain conventions, which are implemented automatically by Jimmer."),(0,r.kt)("p",null,"However, this approach has some issues:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Results in very long method names"),(0,r.kt)("li",{parentName:"ul"},"Cannot implement complex query logic"),(0,r.kt)("li",{parentName:"ul"},"If developers add methods violating conventions, it leads to startup failures rather than compile time errors")),(0,r.kt)("p",null,"So Jimmer provides another approach that allows developers to write queries themselves and control all details."),(0,r.kt)("p",null,"To maximize the safety of static languages, Jimmer provides a strongly typed SQL DSL, rather than weak, string-based solutions like ",(0,r.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html"},"Spring Data JPA's @Query"),"."),(0,r.kt)("p",null,"In Jimmer, query logic can be directly implemented in default methods of the Repository interface."),(0,r.kt)("h2",{id:"dynamic-where"},"Dynamic WHERE"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE; \u2776\n\n    default List<Book> find(@Nullable String name) {\n        return sql() \u2777\n            .createQuery(table)\n            .whereIf( \u2778\n                StringUtils.hasText(name),\n                table.name().ilike(name)\n            )\n            .orderBy(table.name())\n            .orderBy(table.edition().desc())\n            .select(table) \u2779\n            .execute(); \u277a\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(name: String? = null): List<Book> =\n        sql \u2777\n            .createQuery(Book::class) { \u2776\n                name?.takeIf { it.isNotEmpty() }?.let { \u2778\n                    where(table.name ilike it)\n                }\n                orderBy(table.name)\n                orderBy(table.edition.desc())\n                select(table) \u2779\n            }\n            .execute() \u277a\n}\n")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2776"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Java: The parent query is based on the table object ",(0,r.kt)("inlineCode",{parentName:"p"},"Tables.BOOK"),", renamed to ",(0,r.kt)("inlineCode",{parentName:"p"},"table")," for convenience.  "),(0,r.kt)("p",{parentName:"li"},"This rename applies to all default methods of the current interface, so declaring it as a static interface variable is appropriate.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Kotlin: ",(0,r.kt)("inlineCode",{parentName:"p"},"createQuery")," accepts a lambda expression which switches the meaning of ",(0,r.kt)("inlineCode",{parentName:"p"},"this"),", so code inside the lambda can directly use the ",(0,r.kt)("inlineCode",{parentName:"p"},"table")," variable.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2777 "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Java: The ",(0,r.kt)("inlineCode",{parentName:"p"},"sql()")," method inherited from ",(0,r.kt)("inlineCode",{parentName:"p"},"JRepository")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.sql.JSqlClient"),", which is the total entry point for Java API of the SQL DSL.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Kotlin: The ",(0,r.kt)("inlineCode",{parentName:"p"},"sql")," property inherited from ",(0,r.kt)("inlineCode",{parentName:"p"},"KRepository")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.sql.kt.KSqlClient"),", which is the total entry point for Kotlin API of the SQL DSL.")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2778 Only add the where condition when the query parameter is non-null and string length is non-zero."),(0,r.kt)("p",{parentName:"li"},"Obviously, this query is dynamic.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2779 The ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," statement is always at the end. Before ",(0,r.kt)("inlineCode",{parentName:"p"},"select"),", the query has no return type; only after ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," can the return type of the query be determined. This is why ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," appears at the end."),(0,r.kt)("admonition",{parentName:"li",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The practice of putting ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," at the end is not originally invented by Jimmer, it was first introduced in ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/"},"C# linq"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u277a Between ",(0,r.kt)("inlineCode",{parentName:"p"},"select")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"In Java, the expression type is ",(0,r.kt)("inlineCode",{parentName:"li"},"TypedRootQuery<Book>")," "),(0,r.kt)("li",{parentName:"ul"},"In Kotlin, the expression type is ",(0,r.kt)("inlineCode",{parentName:"li"},"KTypedRootQuery<Book>"))),(0,r.kt)("p",{parentName:"li"},"But neither is ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Book>"),"."),(0,r.kt)("p",{parentName:"li"},"This represents a query that is created but not yet executed. It needs to call ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," to actually execute it to get the final result ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Book>"),"."),(0,r.kt)("admonition",{parentName:"li",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The query is not executed immediately after creation, ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," must be called to execute it. This is not a design flaw, but an important capability that the ",(0,r.kt)("a",{parentName:"p",href:"#pagination-queries"},"pagination query")," section will illustrate.")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"execute")," is not the only execution method, in addition to ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),", there are other execution methods:"),(0,r.kt)("table",{parentName:"li"},(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:null},"Return Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Note"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"execute ",(0,r.kt)("em",{parentName:"td"},"(as shown in this example)")),(0,r.kt)("td",{parentName:"tr",align:null},"List","<","T",">"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns a list")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fetchOne"),(0,r.kt)("td",{parentName:"tr",align:null},"T ",(0,r.kt)("em",{parentName:"td"},"(cannot be null)")),(0,r.kt)("td",{parentName:"tr",align:null},"Returns one record, throws exception if no data or multiple data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fetchOneOrNull"),(0,r.kt)("td",{parentName:"tr",align:null},"T ",(0,r.kt)("em",{parentName:"td"},"(can be null)")),(0,r.kt)("td",{parentName:"tr",align:null},"Returns one record, throws exception if multiple data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fetchOptional ",(0,r.kt)("em",{parentName:"td"},"(Java only)")),(0,r.kt)("td",{parentName:"tr",align:null},"Optional wrapping of T or null"),(0,r.kt)("td",{parentName:"tr",align:null},"Returns one record, throws exception if multiple data")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"forEach"),(0,r.kt)("td",{parentName:"tr",align:null},"No return"),(0,r.kt)("td",{parentName:"tr",align:null},"Use when data volume is large, don't want to build collection, just iterate")))),(0,r.kt)("p",{parentName:"li"},"All these execution methods have two overloaded versions:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Version without parameters (current example): Execute based on JDBC connection managed by Spring transaction. Should be called in most cases.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Version with ",(0,r.kt)("inlineCode",{parentName:"p"},"java.sql.Connection")," parameter: Execute based on the JDBC connection specified by the user. "))))),(0,r.kt)("p",null,"Usage:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Do not specify parameter"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = bookRepository\n    .find(null);\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = bookRepository.find()\n")))),(0,r.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc \n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Specify parameter"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository.find("G"); \n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository.find("G")\n')))),(0,r.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere\n    /* highlight-next-line */\n    lower(tb_1_.NAME) like ? /* %g% */\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n")))),(0,r.kt)("h2",{id:"dynamic-join"},"Dynamic JOIN"),(0,r.kt)("p",null,"Next, add a ",(0,r.kt)("inlineCode",{parentName:"p"},"storeName")," parameter to this query method to filter on the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," property of ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore")," associated via the ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.store")," property of the current ",(0,r.kt)("inlineCode",{parentName:"p"},"Book"),"."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE;\n\n    default List<Book> find(\n        @Nullable String name,\n        // highlight-next-line \n        @Nullable String storeName\n    ) {\n        return sql()\n            .createQuery(table)\n            .whereIf(\n                StringUtils.hasText(name),\n                table.name().ilike(name)\n            )\n            // highlight-next-line\n            .whereIf(\n                StringUtils.hasText(storeName),\n                // highlight-next-line\n                table.store().name().ilike(storeName) \n            )\n            .orderBy(table.name())\n            .orderBy(table.edition().desc())\n            .select(table) \n            .execute();\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(\n        name: String? = null,\n        // highlight-next-line\n        storeName: String? = null\n    ): List<Book> =\n        sql\n            .createQuery(Book::class) {\n                name?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.name ilike it)\n                }\n                // highlight-next-line\n                storeName?.takeIf { it.isNotEmpty() }?.let {\n                    // highlight-next-line\n                    table.store.name ilike it\n                }\n                orderBy(table.name)\n                orderBy(table.edition.desc())\n                select(table)\n            }\n            .execute()\n}\n")))),(0,r.kt)("p",null,"Where Java's ",(0,r.kt)("inlineCode",{parentName:"p"},"table.store().name()")," or Kotlin's ",(0,r.kt)("inlineCode",{parentName:"p"},"table.store.name")," means:"),(0,r.kt)("p",null,"Starting from the current queried object ",(0,r.kt)("inlineCode",{parentName:"p"},"Book"),", join to the ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore")," object via the association property ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.store"),", and finally apply filter condition on the ",(0,r.kt)("inlineCode",{parentName:"p"},"BookStore.name")," property."),(0,r.kt)("p",null,"Obviously, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"storeName")," parameter is not specified, the final SQL will not contain JOIN, no need to demonstrate. "),(0,r.kt)("p",null,"So let's demonstrate the case where the ",(0,r.kt)("inlineCode",{parentName:"p"},"storeName")," parameter is specified."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository.find(null, "M");\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository.find(storeName = "M") \n')))),(0,r.kt)("p",null,"The generated SQL is (formatted for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\n/* highlight-next-line */ \ninner join BOOK_STORE as tb_2_\n    on tb_1_.STORE_ID = tb_2_.ID\nwhere\n    lower(tb_2_.NAME) like ?  \norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc \n")),(0,r.kt)("h2",{id:"subqueries"},"Subqueries"),(0,r.kt)("p",null,"Next, add an ",(0,r.kt)("inlineCode",{parentName:"p"},"authorName")," parameter to this query method to filter on the ",(0,r.kt)("inlineCode",{parentName:"p"},"firstName")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"lastName")," properties of ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," associated via ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," property of the current ",(0,r.kt)("inlineCode",{parentName:"p"},"Book"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Unfortunately, if you try to emulate the previous example's ",(0,r.kt)("inlineCode",{parentName:"p"},"table.store.name")," by writing ",(0,r.kt)("inlineCode",{parentName:"p"},"table.authors.firstName"),", you'll find there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"table.authors")," option in the IDE auto-complete of ",(0,r.kt)("inlineCode",{parentName:"p"},"table"),"."),(0,r.kt)("p",{parentName:"admonition"},"This is because ",(0,r.kt)("inlineCode",{parentName:"p"},"Book.authors")," is a collection association (collective term for one-to-many and many-to-many associations). Blindly joining other objects via collection associations will lead to duplicate data in the query results. More importantly, this duplication is fatal for pagination queries to be shown later. "),(0,r.kt)("p",{parentName:"admonition"},"For more details, please refer to ",(0,r.kt)("a",{parentName:"p",href:"../../query/dynamic-join/table-ex"},"Pagination Safety"),"."),(0,r.kt)("p",{parentName:"admonition"},"If you read ",(0,r.kt)("a",{parentName:"p",href:"../../query/dynamic-join/table-ex"},"Pagination Safety"),", you'll know you can force connecting via collection associations using ",(0,r.kt)("inlineCode",{parentName:"p"},"table.asTableEx().authors"),". However, this capability is not suitable for use here."),(0,r.kt)("p",{parentName:"admonition"},"In short, Jimmer's API will subtly hint that this should be implemented using subqueries rather than JOIN. ")),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.AuthorTableEx;\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE;\n\n    default List<Book> find(\n        @Nullable String name,\n        @Nullable String storeName,\n        // highlight-next-line\n        @Nullable String authorName\n    ) {\n        AuthorTableEx author = TableExes.AUTHOR_TABLE_EX; \u2776\n\n        return sql()\n            .createQuery(table)\n            .whereIf(\n                StringUtils.hasText(name),\n                table.name().ilike(name)\n            )\n            .whereIf(\n                StringUtils.hasText(storeName),\n                table.store().name().ilike(storeName) \n            )\n            // highlight-next-line\n            .whereIf(\n                StringUtils.hasText(authorName),\n                table.id().in(\n                    sql()\n                        // highlight-next-line\n                        .createSubQuery(author) \u2777\n                        .where(\n                            Predicate.or(\n                                author.firstName().ilike(authorName),\n                                author.lastName().ilike(authorName)\n                            )\n                        )\n                        .select(\n                            author.books().id()\n                        )\n                )\n            )\n            .orderBy(table.name())\n            .orderBy(table.edition().desc())\n            .select(table) \n            .execute();\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Author\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(\n        name: String? = null,\n        storeName: String? = null,\n        // highlight-next-line\n        authorName: String? = null\n    ): List<Book> =\n        sql\n            .createQuery(Book::class) {\n                name?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.name ilike it)\n                }\n                storeName?.takeIf { it.isNotEmpty() }?.let {\n                    table.store.name ilike it\n                }\n                // highlight-next-line\n                authorName?.takeIf { it.isNotEmpty() }?.let {\n                    where(\n                        // highlight-next-line\n                        table.id valueIn subQuery(Author::class) { \u2776\u2777\n                            where(\n                                or(\n                                    table.firstName ilike it,\n                                    table.lastName ilike it\n                                )\n                            )\n                            select(table.books.id)\n                        }\n                    )\n                }\n                orderBy(table.name)\n                orderBy(table.edition.desc())\n                select(table)\n            }\n            .execute()\n}\n")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2776"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Java: The subquery is based on the global variable ",(0,r.kt)("inlineCode",{parentName:"p"},"TableExes.AUTHOR_TABLE_EX"),", alias it to ",(0,r.kt)("inlineCode",{parentName:"p"},"author")," for subsequent convenience."),(0,r.kt)("p",{parentName:"li"},"Here, the subquery is based on ",(0,r.kt)("inlineCode",{parentName:"p"},"TableExes.AUTHOR_TABLE_EX")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"Tables.AUTHOR_TABLE")," so that ",(0,r.kt)("inlineCode",{parentName:"p"},"select(table.books().id())")," can compile."),(0,r.kt)("p",{parentName:"li"},"Please read ",(0,r.kt)("a",{parentName:"p",href:"../../query/dynamic-join/table-ex"},"query/Pagination Safety")," for more details.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Kotlin: ",(0,r.kt)("inlineCode",{parentName:"p"},"subQuery")," accepts a lambda expression where ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," is redefined, so ",(0,r.kt)("inlineCode",{parentName:"p"},"table")," variable can be used directly inside, but note:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Inside subquery lambda: ",(0,r.kt)("inlineCode",{parentName:"li"},"table")," var represents ",(0,r.kt)("inlineCode",{parentName:"li"},"KNonNullTableEx<Author>")),(0,r.kt)("li",{parentName:"ul"},"Outside subquery lambda, inside parent query lambda: ",(0,r.kt)("inlineCode",{parentName:"li"},"table")," var represents ",(0,r.kt)("inlineCode",{parentName:"li"},"KNonNullTable<Book>")," "),(0,r.kt)("li",{parentName:"ul"},"If need to reference parent query table inside subquery (not shown in this example, usually used for correlated subqueries): please use ",(0,r.kt)("inlineCode",{parentName:"li"},"parentTable")))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2777  Create subquery"))),(0,r.kt)("p",null,"Obviously, if the ",(0,r.kt)("inlineCode",{parentName:"p"},"authorName")," parameter is not specified, the final SQL will not contain sub query, no need to demonstrate."),(0,r.kt)("p",null,"So let's demonstrate the case where ",(0,r.kt)("inlineCode",{parentName:"p"},"authorName")," is specified."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository.find(null, null, "A"); \n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository.find(authorName = "M")\n')))),(0,r.kt)("p",null,"The generated SQL is (formatted for readability): "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere\n    tb_1_.ID in (\n        /* highlight-next-line */\n        select tb_3_.BOOK_ID\n        from AUTHOR as tb_2_\n        inner join BOOK_AUTHOR_MAPPING as tb_3_\n            on tb_2_.ID = tb_3_.AUTHOR_ID\n        where\n            lower(tb_2_.FIRST_NAME) like ? /* %a% */ \n        or\n            lower(tb_2_.LAST_NAME) like ? /* %a% */ \n    )\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n")),(0,r.kt)("h2",{id:"dynamic-order-by"},"Dynamic ORDER BY"),(0,r.kt)("p",null,"So far, the sorting in our queries has been static. We expect to accept external parameters to achieve dynamic sorting."),(0,r.kt)("p",null,"Add a parameter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Sort")," to the query method and use it to sort."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.AuthorTableEx;\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.babyfish.jimmer.spring.repository.SpringOrders;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE;\n\n    default List<Book> find(\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String authorName,\n        // highlight-next-line\n        @Nullable Sort sort\n    ) {\n        AuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\n        return sql()\n            .createQuery(table)\n            .whereIf(\n                StringUtils.hasText(name),\n                table.name().ilike(name)\n            )\n            .whereIf(\n                StringUtils.hasText(storeName),\n                table.store().name().ilike(storeName)\n            )\n            .whereIf(\n                StringUtils.hasText(authorName),\n                table.id().in(\n                    sql()\n                        .createSubQuery(author)\n                        .where(\n                            Predicate.or(\n                                author.firstName().ilike(authorName),\n                                author.lastName().ilike(authorName)\n                            )\n                        )\n                        .select(\n                            author.books().id()\n                        )\n                )\n            )\n            // highlight-next-line\n            .orderBy(SpringOrders.toOrders(table, sort))\n            .select(table)\n            .execute();\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Author\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.spring.repository.orderBy\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\nimport org.springframework.data.domain.Sort\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(\n        name: String? = null,\n        storeName: String? = null,\n        authorName: String? = null,\n        // highlight-next-line\n        sort: Sort? = null\n    ): List<Book> =\n        sql\n            .createQuery(Book::class) {\n                name?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.name ilike it)\n                }\n                storeName?.takeIf { it.isNotEmpty() }?.let {\n                    table.store.name ilike it\n                }\n                authorName?.takeIf { it.isNotEmpty() }?.let {\n                    where(\n                        table.id valueIn subQuery(Author::class) {\n                            where(\n                                or(\n                                    table.firstName ilike it,\n                                    table.lastName ilike it\n                                )\n                            )\n                            select(table.books.id)\n                        }\n                    )\n                }\n                // highlight-next-line\n                orderBy(sort)\n                select(table)\n            }\n            .execute()\n}\n")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For Java, ",(0,r.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.spring.repository.SpringOrders.toOrders")," is needed to convert the Spring Data Sort object to the sorting accepted by Jimmer.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"For Kotlin, ",(0,r.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.spring.repository.orderBy")," extends the capability of Jimmer's underlying SQL DSL, so the query object can sort based on the Spring Data Sort object."))),(0,r.kt)("p",null,"To facilitate the top-level code to accept sorting strings from the client, Jimmer provides the utility class ",(0,r.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.spring.model.SortUtils")," to convert the string passed from the frontend to ",(0,r.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Sort"),". "),(0,r.kt)("p",null,"It can be used like:"),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Sort sort = SortUtils.toSort(\n    "store.name asc", "name asc", "edition desc"\n); \n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sort = SortUtils.toSort(\n    "store.name asc", "name asc", "edition desc"\n)\n')))),"or",(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Sort sort = SortUtils.toSort(\n    "store.name asc, name asc, edition desc"  \n);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sort = SortUtils.toSort(\n    "store.name asc, name asc, edition desc"\n);\n')))),(0,r.kt)("p",null,"Now let's demonstrate the usage of dynamic sorting by specifying all other query parameters as null to focus on the sorting logic."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository.find(\n    null,\n    null,\n    null, \n    SortUtils.toSort(\n        "store.name", // This sort implies JOIN\n        "price desc" \n    )\n);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository.find(\n    sort = SortUtils.toSort(\n        "store.name", // This sort implies JOIN\n        "price desc"\n    )\n)\n')))),(0,r.kt)("p",null,"The generated SQL is (formatted for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_  \n/* Dynamic sort causes table join */\n/* highlight-next-line */ \nleft join BOOK_STORE as tb_2_\n    on tb_1_.STORE_ID = tb_2_.ID \n/* Dynamic sort */\n/* highlight-next-line */\norder by\n    tb_2_.NAME asc,\n    tb_1_.PRICE desc\n")),(0,r.kt)("h2",{id:"pagination"},"Pagination"),(0,r.kt)("p",null,"Let's continue improving the example by adding pagination capability."),(0,r.kt)("p",null,"To implement pagination, need:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Replace the ",(0,r.kt)("inlineCode",{parentName:"li"},"org.springframework.data.domain.Sort")," type parameter with ",(0,r.kt)("inlineCode",{parentName:"li"},"org.springframework.data.domain.Pageable")," ",(0,r.kt)("em",{parentName:"li"},"(",(0,r.kt)("inlineCode",{parentName:"em"},"Pageable")," contains ",(0,r.kt)("inlineCode",{parentName:"em"},"Sort"),")")," "),(0,r.kt)("li",{parentName:"ul"},"Change return value from ",(0,r.kt)("inlineCode",{parentName:"li"},"java.util.List<Book>")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"org.springframework.data.domain.Page<Book>")),(0,r.kt)("li",{parentName:"ul"},"Internally use specific APIs to achieve pagination in one statement")),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.AuthorTableEx;\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.babyfish.jimmer.spring.repository.SpringOrders;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE;\n\n    default Page<Book> find( \u2776\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String authorName,\n        // highlight-next-line  \n        Pageable pageable \u2777\n    ) {\n        AuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\n        // highlight-next-line\n        return pager(pageable).execute( \u2778\n            sql()\n                .createQuery(table)\n                .whereIf(\n                    StringUtils.hasText(name),\n                    table.name().ilike(name)\n                )\n                .whereIf(\n                    StringUtils.hasText(storeName),\n                    table.store().name().ilike(storeName)\n                )\n                .whereIf(\n                    StringUtils.hasText(authorName),\n                    table.id().in(\n                        sql()\n                            .createSubQuery(author)\n                            .where(\n                                Predicate.or(\n                                    author.firstName().ilike(authorName),\n                                    author.lastName().ilike(authorName)\n                                )\n                            )\n                            .select(\n                                author.books().id()\n                            )\n                    )\n                )\n                .orderBy(SpringOrders.toOrders(table, pageable.getSort())) \u2779\n                .select(table)\n        );\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Author\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.spring.repository.orderBy\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(\n        name: String? = null,\n        storeName: String? = null,\n        authorName: String? = null,\n        // highlight-next-line\n        pageable: Pageable \u2777\n    ): Page<Book> = \u2776\n        sql\n            .createQuery(Book::class) {\n                name?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.name ilike it)\n                }\n                storeName?.takeIf { it.isNotEmpty() }?.let {\n                    table.store.name ilike it\n                }\n                authorName?.takeIf { it.isNotEmpty() }?.let {\n                    where(\n                        table.id valueIn subQuery(Author::class) {\n                            where(\n                                or(\n                                    table.firstName ilike it,\n                                    table.lastName ilike it\n                                )\n                            )\n                            select(table.books.id)\n                        }\n                    )\n                }\n                orderBy(pageable.sort) \u2779\n                select(table)\n            }\n            // highlight-next-line\n            .fetchPage( \u2778\n                pageable.pageNumber,\n                pageable.pageSize\n            )\n}\n")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2776 Return ",(0,r.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Page")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.List"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2777 Parameter becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Pageable")," ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2778 Execute paged query"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Java"),(0,r.kt)("p",{parentName:"li"},"Create a Pager object to paginate the original ",(0,r.kt)("strong",{parentName:"p"},"unexecuted")," query"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pager")," is a method inherited from base interface ",(0,r.kt)("inlineCode",{parentName:"li"},"JRepository/KRepository")),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"pager")," method has multiple overloaded versions, here the one called accepts a pagable object "),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"pager")," method creates a ",(0,r.kt)("inlineCode",{parentName:"li"},"Pager")," object, which has an ",(0,r.kt)("inlineCode",{parentName:"li"},"execute")," method that accepts the ",(0,r.kt)("strong",{parentName:"li"},"unexecuted")," original query"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Kotlin"),(0,r.kt)("p",{parentName:"li"},"Kotlin API provides the extension method ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchPage")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"KConfigurableRootQuery<*, E>")," types to implement paged queries")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2779 Get sort object from pageable to perform dynamic sorting"))),(0,r.kt)("p",null,"Now let's demonstrate the usage of paging query by specifying all other query parameters as null to focus on the pagination logic."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository.find(\n    null,\n    null,\n    null,\n    PageRequest.of(\n        1, // zero based, 1 means second page\n        5,\n        SortUtils.toSort("name, edition desc")\n    )\n);\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository.find(\n    pageable = PageRequest.of(\n        1, // zero based, 1 means second page\n        5,\n        SortUtils.toSort("name, edition desc")\n    )\n)\n')))),(0,r.kt)("p",null,"The returned Page object is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    // highlight-next-line\n    "content":[\n        {\n            "id":10,\n            "name":"GraphQL in Action",\n            "edition":1,\n            "price":80,\n            "store":{\n                "id":2\n            }\n        },\n        {\n            "id":3,\n            "name":"Learning GraphQL",\n            "edition":3,\n            "price":51,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":2,\n            "name":"Learning GraphQL",\n            "edition":2,\n            "price":55,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":1,\n            "name":"Learning GraphQL",\n            "edition":1,\n            "price":45,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":9,\n            "name":"Programming TypeScript",\n            "edition":3,\n            "price":48,\n            "store":{\n                "id":1\n            }\n        }\n    ],\n    "pageable":{\n        "sort":{\n            "unsorted":false,\n            "sorted":true,\n            "empty":false\n        },\n        "pageNumber":1,\n        "pageSize":5,\n        "offset":5,\n        "paged":true,\n        "unpaged":false\n    },\n    // highlight-start\n    "totalPages":3,\n    "totalElements":12, \n    "last":false,\n    "numberOfElements":5,\n    // highlight-end\n    "first":false,\n    "sort":{\n        "unsorted":false,\n        "sorted":true,\n        "empty":false\n    },\n    "number":1,\n    "size":5,\n    "empty":false\n}\n')),(0,r.kt)("p",null,"The generated SQL is (formatted for readability):   "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query total rows before pagination */\nselect count(tb_1_.ID) from BOOK as tb_1_  \n\n/* Step 2: Query data within one page */\nselect tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\norder by \n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n/* MySQL pagination */  \n/* highlight-next-line */\nlimit ?, /* 5(offset) */ ? /* 5(limit) */\n")),(0,r.kt)("h2",{id:"object-fetcher"},"Object Fetcher"),(0,r.kt)("p",null,"Object fetchers are one of Jimmer's signature features, allowing querying of arbitrary complex data structures instead of just simple entity objects."),(0,r.kt)("p",null,"To use it, need:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add a parameter of type ",(0,r.kt)("inlineCode",{parentName:"li"},"org.babyfish.jimmer.sql.fetcher.Fetcher<Current Entity>")),(0,r.kt)("li",{parentName:"ul"},"Change the ",(0,r.kt)("inlineCode",{parentName:"li"},"select")," call of the top-level query from ",(0,r.kt)("inlineCode",{parentName:"li"},"select(table)")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"select(table.fetch(fetcher))"))),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.AuthorTableEx;\nimport com.example.model.Book;\nimport com.example.model.BookTable;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.babyfish.jimmer.spring.repository.SpringOrders;\nimport org.babyfish.jimmer.sql.fetcher.Fetcher;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.util.StringUtils;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    BookTable table = Tables.BOOK_TABLE;\n\n    default Page<Book> find(\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String authorName,\n        Pageable pageable,\n        // highlight-next-line\n        @Nullable Fetcher<Book> fetcher\n    ) {\n        AuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\n        return pager(pageable).execute(\n            sql()\n                .createQuery(table)\n                .whereIf(\n                    StringUtils.hasText(name),\n                    table.name().ilike(name)\n                )\n                .whereIf(\n                    StringUtils.hasText(storeName),\n                    table.store().name().ilike(storeName)\n                )\n                .whereIf(\n                    StringUtils.hasText(authorName),\n                    table.id().in(\n                        sql()\n                            .createSubQuery(author)\n                            .where(\n                                Predicate.or(\n                                    author.firstName().ilike(authorName), \n                                    author.lastName().ilike(authorName)\n                                )\n                            )\n                            .select(\n                                author.books().id()\n                            )\n                    )\n                )\n                .orderBy(SpringOrders.toOrders(table, pageable.getSort()))\n                .select(\n                    // highlight-next-line\n                    table.fetch(fetcher) \n                )\n        );\n    }\n}\n"))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Author\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.babyfish.jimmer.spring.repository.orderBy\nimport org.babyfish.jimmer.sql.fetcher.Fetcher;\nimport org.babyfish.jimmer.sql.kt.ast.expression.*\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\n\ninterface BookRepository : KRepository<BookStore, Long> {\n\n    fun find(\n        name: String? = null,\n        storeName: String? = null,\n        authorName: String? = null,\n        pageable: Pageable,\n        // highlight-next-line\n        fetcher: Fetcher<Book>? = null\n    ): Page<Book> =\n        sql\n            .createQuery(Book::class) {\n                name?.takeIf { it.isNotEmpty() }?.let {\n                    where(table.name ilike it)\n                }\n                storeName?.takeIf { it.isNotEmpty() }?.let {\n                    table.store.name ilike it\n                }\n                authorName?.takeIf { it.isNotEmpty() }?.let {\n                    where(\n                        table.id valueIn subQuery(Author::class) {\n                            where(\n                                or(\n                                    table.firstName ilike it,\n                                    table.lastName ilike it\n                                )\n                            )\n                            select(table.books.id)\n                        }\n                    )\n                }\n                orderBy(pageable.sort)\n                select(\n                    // highlight-next-line\n                    table.fetch(fetcher)\n                )\n            }\n            // highlight-next-line\n            .fetchPage(\n                pageable.pageNumber,\n                pageable.pageSize\n            )\n}\n")))),(0,r.kt)("p",null,"If no fetcher is passed or simple object shape is passed, the result will necessarily be similar to previous examples, no need to repeat."),(0,r.kt)("p",null,"So let's just demonstrate querying a complex data structure directly. To focus on the object fetcher, all other query parameters are specified as null except the fetcher."),(0,r.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Page<Book> page = bookRepository\n    .find(\n        null,\n        null,\n        null,\n        PageRequest.of(\n            1, // zero based, 1 means second page\n            5,\n            SortUtils.toSort("name, edition desc")\n        ),\n        // highlight-next-line\n        Fetchers.BOOK_FETCHER\n            .allScalarFields()\n            // highlight-next-line\n            .store(\n                Fetchers.BOOK_FETCHER\n                    .name() // associated object only queries id (implicit+mandatory) and name\n            )\n            // highlight-next-line\n            .authors(\n                Fetchers.AUTHOR_FETCHER\n                    // associated object only queries id (implicit+mandatory), firstName and lastName\n                    .firstName().lastName()\n            )\n    );\n'))),(0,r.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val page = bookRepository\n    .find(\n        pageable = PageRequest.of(\n            1, // zero based, 1 means second page\n            5,\n            SortUtils.toSort("name, edition desc")\n        ),\n        // highlight-next-line\n        fetcher = newFetcher(Book::class).by {\n            allScalarFields()\n            // highlight-next-line\n            store {\n                // associated object only queries \n                // id (implicit+mandatory) and name\n                name()\n            }\n            // highlight-next-line\n            authors {\n                // associated object only queries \n                // id (implicit+mandatory), firstName and lastName\n                firstName()\n                lastName()\n            }\n        }\n    )\n')))),(0,r.kt)("p",null,"The returned Page object is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "content":[\n        {\n            "id":10,\n            "name":"GraphQL in Action",\n            "edition":1,\n            "price":80,\n            // highlight-next-line\n            "store":{\n                "id":2,\n                "name":"MANNING"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":5,\n                    "firstName":"Samer",\n                    "lastName":"Buna"\n                }\n            ]\n        },\n        {\n            "id":3,\n            "name":"Learning GraphQL",\n            "edition":3,\n            "price":51,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,\n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":2,\n            "name":"Learning GraphQL",\n            "edition":2,\n            "price":55,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,\n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":1,\n            "name":"Learning GraphQL",\n            "edition":1,\n            "price":45,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,\n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":9,\n            "name":"Programming TypeScript",\n            "edition":3,\n            "price":48,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":4,\n                    "firstName":"Boris",\n                    "lastName":"Cherny"\n                }\n            ]\n        }\n    ],\n    "pageable":{\n        "sort":{\n            "unsorted":false,\n            "sorted":true,\n            "empty":false\n        },\n        "pageNumber":1,\n        "pageSize":5,\n        "offset":5,\n        "paged":true,\n        "unpaged":false\n    },\n    "totalPages":3,\n    "totalElements":12,\n    "last":false,\n    "sort":{\n        "unsorted":false,\n        "sorted":true,\n        "empty":false\n    },\n    "numberOfElements":5,\n    "number":1,  \n    "first":false,\n    "size":5,\n    "empty":false\n}\n')),(0,r.kt)("p",null,"The generated SQL is (formatted for readability):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query total rows before pagination */\nselect count(tb_1_.ID) from BOOK as tb_1_\n\n/* Step 2: Query aggregate root objects within one page */\nselect tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID  \nfrom BOOK as tb_1_\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n/* MySQL pagination */\nlimit ?, /* 5(offset) */ ? /*  5(limit) */  \n\n/* \n * Step 3: For the 5 paged data (not 12 rows before paging),  \n * query the associated objects of property `Book.store`\n * \n * Note:\n * Here the foreign key `STORE_ID` of the 5 records will be queried,\n * so finding parent objects directly via foreign key. \n * Although there are 5 rows of data, the foreign keys only  \n * have two distinct values, so only two SQL params.\n */\nselect tb_1_.ID, tb_1_.NAME\nfrom BOOK_STORE as tb_1_\nwhere tb_1_.ID in (\n    ?/* 2 */, ?/* 1 */\n)\n\n/* \n * Step 4: For the 5 paged data (not 12 rows before paging),\n * query the associated objects of property `Book.authors` \n */  \nselect tb_2_.BOOK_ID, tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME\nfrom AUTHOR as tb_1_\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (\n    ?/* 10 */, ?/* 3 */, ?/* 2 */, ?/* 1 */, ?/* 9 */\n)\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Whether it is complex queries discussed in this article, or simple queries discussed in ",(0,r.kt)("a",{parentName:"p",href:"./abstract"},"previous article"),", as long as the query returns entity objects or their collections rather than simple column tuples, it is highly recommended to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"Fetcher")," parameter to make all object queries as powerful in data structure shaping as ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQL"),"."),(0,r.kt)("p",{parentName:"admonition"},"This brings great convenience to higher level business code.")))}c.isMDXComponent=!0}}]);