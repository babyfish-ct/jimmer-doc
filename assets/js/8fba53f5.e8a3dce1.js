"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[1342],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>c});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(a),c=i,b=u["".concat(s,".").concat(c)]||u[c]||m[c]||r;return a?n.createElement(b,l(l({ref:t},d),{},{components:a})):n.createElement(b,l({ref:t},d))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},85162:(e,t,a)=>{a.d(t,{Z:()=>l});var n=a(67294),i=a(34334);const r="tabItem_Ymn6";function l(e){let{children:t,hidden:a,className:l}=e;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(r,l),hidden:a},t)}},65488:(e,t,a)=>{a.d(t,{Z:()=>c});var n=a(83117),i=a(67294),r=a(34334),l=a(72389),o=a(67392),s=a(7094),p=a(12466);const d="tabList__CuJ",m="tabItem_LNqP";function u(e){var t;const{lazy:a,block:l,defaultValue:u,values:c,groupId:b,className:h}=e,f=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),k=c??f.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),y=(0,o.l)(k,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===u?u:u??(null==(t=f.find((e=>e.props.default)))?void 0:t.props.value)??f[0].props.value;if(null!==g&&!k.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${k.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:v,setTabGroupChoices:N}=(0,s.U)(),[O,w]=(0,i.useState)(g),C=[],{blockElementScrollPositionUntilNextRender:T}=(0,p.o5)();if(null!=b){const e=v[b];null!=e&&e!==O&&k.some((t=>t.value===e))&&w(e)}const x=e=>{const t=e.currentTarget,a=C.indexOf(t),n=k[a].value;n!==O&&(T(t),w(n),null!=b&&N(b,String(n)))},D=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=C.indexOf(e.currentTarget)+1;a=C[t]??C[0];break}case"ArrowLeft":{const t=C.indexOf(e.currentTarget)-1;a=C[t]??C[C.length-1];break}}null==(t=a)||t.focus()};return i.createElement("div",{className:(0,r.Z)("tabs-container",d)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":l},h)},k.map((e=>{let{value:t,label:a,attributes:l}=e;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:O===t?0:-1,"aria-selected":O===t,key:t,ref:e=>C.push(e),onKeyDown:D,onFocus:x,onClick:x},l,{className:(0,r.Z)("tabs__item",m,null==l?void 0:l.className,{"tabs__item--active":O===t})}),a??t)}))),a?(0,i.cloneElement)(f.filter((e=>e.props.value===O))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==O})))))}function c(e){const t=(0,l.Z)();return i.createElement(u,(0,n.Z)({key:String(t)},e))}},33635:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>m});var n=a(83117),i=(a(67294),a(3905)),r=a(65488),l=a(85162);const o={sidebar_position:9,title:"Database Validation"},s=void 0,p={unversionedId:"configuration/database-validation",id:"configuration/database-validation",title:"Database Validation",description:"Function Introduction",source:"@site/docs/configuration/database-validation.mdx",sourceDirName:"configuration",slug:"/configuration/database-validation",permalink:"/jimmer-doc/docs/configuration/database-validation",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/configuration/database-validation.mdx",tags:[],version:"current",lastUpdatedAt:1711320943,formattedLastUpdatedAt:"Mar 24, 2024",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"Database Validation"},sidebar:"tutorialSidebar",previous:{title:"Trigger Type",permalink:"/jimmer-doc/docs/configuration/trigger-type"},next:{title:"Microservice",permalink:"/jimmer-doc/docs/configuration/micro-service"}},d={},m=[{value:"Function Introduction",id:"function-introduction",level:2},{value:"Enable Validation",id:"enable-validation",level:2},{value:"Resolve Table Conflicts",id:"resolve-table-conflicts",level:2},{value:"Temporarily ignore partial validation",id:"temporarily-ignore-partial-validation",level:2}],u={toc:m};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"function-introduction"},"Function Introduction"),(0,i.kt)("p",null,"Admittedly, Jimmer's strongly typed SQL DSL can expose problems as much as possible at compile time, and most errors can be prevented before testing. But this is not enough."),(0,i.kt)("p",null,"The strongly typed SQL DSL can only improve the reliability of the ",(0,i.kt)("inlineCode",{parentName:"p"},"entity model -> business code")," link, but cannot guarantee the reliability of the ",(0,i.kt)("inlineCode",{parentName:"p"},"database structure -> entity model")," link."),(0,i.kt)("p",null,"There is also a derived problem. If developers get reliable applications in the test environment, how to ensure that the application remains reliable after being transplanted to the production environment?"),(0,i.kt)("p",null,"Database validation is a very important feature that is used to verify the consistency between the database structure and the entity model definition."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("strong",{parentName:"p"},"Validation Rules")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Verify that table names, column names, sequence names are consistent with definitions in the entity model.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Verify that the nullity of columns is consistent with the definitions of properties in the entity model. "),(0,i.kt)("p",{parentName:"li"},"If a property is decorated with ",(0,i.kt)("inlineCode",{parentName:"p"},"@OneToOne(inputNotNull = true)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"@ManyToOne(inputNotNull = true)"),",\nthe nullity of the property itself is ignored. it is considered that the corresponding foreign key in the data cannot be null.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For the id property of each entity in the entity model, verify that the database has a primary key constraint that exactly matches.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For true foreign keys defined in the entity model (see ",(0,i.kt)("a",{parentName:"p",href:"../mapping/base/foreignkey"},"True and False Foreign Keys"),"), verify that the database has exactly matching foreign key constraints.")))),(0,i.kt)("h2",{id:"enable-validation"},"Enable Validation"),(0,i.kt)("p",null,"There are two ways to start validation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use Spring Boot Starter"),(0,i.kt)("p",{parentName:"li"},"Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml")," ",(0,i.kt)("em",{parentName:"p"},"(or application.properties)")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"jimmer:\n    database-validation-mode: ERROR \n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use underlying API"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    ...Omit other configurations...\n    .build();\n"))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    ...Omit other configurations...\n}\n")))))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DatabaseValidationMode")," is an enum type with three values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"NONE"),": Don't validate database structure, this is the default behavior.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"WARNING"),": Validate database structure, if the database structure is inconsistent with the entity model definition, it does not prevent the program from running, just prints warning information in the log.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ERROR"),": Validate database structure, if the database structure is inconsistent with the entity model definition, an exception will be thrown to prevent the program from running."))),(0,i.kt)("h2",{id:"resolve-table-conflicts"},"Resolve Table Conflicts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Entity types must correspond to a table in the database, whether the table name is explicitly configured by the developer via ",(0,i.kt)("inlineCode",{parentName:"p"},"@Table")," or automatically determined by the ",(0,i.kt)("a",{parentName:"p",href:"../mapping/base/naming-strategy"},"naming strategy"),". ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Association properties based on join tables must correspond to a real join table in the database, whether the table name is explicitly configured by the developer via ",(0,i.kt)("inlineCode",{parentName:"p"},"@JoinTable")," or automatically determined by the ",(0,i.kt)("a",{parentName:"p",href:"../mapping/base/naming-strategy"},"naming strategy"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ID whose auto growth strategy is ",(0,i.kt)("inlineCode",{parentName:"p"},"SEQUENCE")," must correspond to a sequence in the database, whether the sequence name is explicitly configured by the developer via ",(0,i.kt)("inlineCode",{parentName:"p"},"@GeneratedValue")," or automatically determined by the ",(0,i.kt)("a",{parentName:"p",href:"../mapping/base/naming-strategy"},"naming strategy")," ."))),(0,i.kt)("p",null,"When the program starts, Jimmer needs to query the database metadata to verify whether these tables or sequences exist. And if they exist, whether their internal structures are correct ",(0,i.kt)("em",{parentName:"p"},"(for tables)"),"."),(0,i.kt)("p",null,"However, since database often support multiple sub-databases, and sub-databases can authorize each other, the JDBC connection may see tables with the same name in different database users, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"db1.BOOK"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"db2.BOOK"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"db3.BOOK"),". This is called table conflict."),(0,i.kt)("p",null,'Of course, Jimmer can extract the database name from the JDBC connection metadata, for example, extract "db1" from ',(0,i.kt)("inlineCode",{parentName:"p"},"jdbc:mysql://localhost:3306/db1"),", and first look for table information in the automatically extracted sub-database for verification.\nHowever, this method is not always valid. As long as the specified table cannot be found in the current sub-database, it will look for it in other sub-databases, which may lead to table conflict issues."),(0,i.kt)("p",null,"To solve this problem, the following two methods are available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Specify strict table names or sequence names, for example:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Change ",(0,i.kt)("inlineCode",{parentName:"p"},'@Table(name = "BOOK")')," to ",(0,i.kt)("inlineCode",{parentName:"p"},'@Table(name = "db1.BOOK")'),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Change ",(0,i.kt)("inlineCode",{parentName:"p"},'@JoinTable(name = "BOOK_AUTHOR_MAPPING")')," to ",(0,i.kt)("inlineCode",{parentName:"p"},'@JoinTable(name = "db1.BOOK_AUTHOR_MAPPING")'),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Change ",(0,i.kt)("inlineCode",{parentName:"p"},'@GeneratedValue(sequenceName = "BOOK_ID_SEQ")')," to ",(0,i.kt)("inlineCode",{parentName:"p"},'@GeneratedValue(sequenceName = "db1.BOOK_ID_SEQ")'),".")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Explicitly specify the sub-database name used for validation, which can be divided into two methods:"),(0,i.kt)("p",{parentName:"li"},"There are two ways to start validation"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use Spring Boot Starter"),(0,i.kt)("p",{parentName:"li"},"Modify ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml")," ",(0,i.kt)("em",{parentName:"p"},"(or application.properties)")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"jimmer:\ndatabase-validation:\n    mode: ERROR\n    # highlight-next-line  \n    catalog: db1\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"jimmer.database-validation-mode")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"jimmer.database-validation.mode")," are equivalent"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use underlying API"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    // highlight-next-line\n    .setDatabaseValidationCatalog("db1")\n    ...Omit other configurations...\n    .build();\n'))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sqlClient = newKSqlClient {\n    setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    // highlight-next-line\n    setDatabaseValidationCatalog("db1")\n    ...Omit other configurations...\n}\n')))))))),(0,i.kt)("p",null,"Similarly, schema can also be specified, for example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Direct configuration: ",(0,i.kt)("inlineCode",{parentName:"p"},'@Table(name = "mydatabase.myschema.BOOK")')," ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Configure in SpringBoot's ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml")," file"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"jimmer:\n  database-validation:\n    mode: ERROR\n    catalog: mydatabase\n    # highlight-next-line\n    schema: myschema\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Underlying API configuration"),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    .setDatabaseValidationCatalog("mydatabase")\n    // highlight-next-line\n    setDatabaseValidationSchema("myschema")\n    ...Omit other configurations...\n    .build();\n'))),(0,i.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sqlClient = newKSqlClient {\n    setDatabaseValidationMode(\n        DatabaseValidationMode.ERROR\n    )\n    setDatabaseValidationCatalog("mydatabase")\n    // highlight-next-line\n    setDatabaseValidationSchema("myschema")\n    ...Omit other configurations...\n}\n')))))),(0,i.kt)("h2",{id:"temporarily-ignore-partial-validation"},"Temporarily ignore partial validation"),(0,i.kt)("p",null,"Sometimes developers are developing a new feature that is incomplete and cannot be verified. Developers will naturally not run unfinished features and expect unfinished parts not to verify the database structure."),(0,i.kt)("p",null,"For this, Jimmer provides the annotation ",(0,i.kt)("inlineCode",{parentName:"p"},"@org.babyfish.jimmer.sql.DatabaseValidationIgnore"),". This annotation has the following two usages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Annotate entity interfaces to indicate that the entire entity does not need to be verified.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Annotate entity properties to indicate that specific properties do not need to be verified."))))}c.isMDXComponent=!0}}]);