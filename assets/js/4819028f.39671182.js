"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[6397],{56778:(e,n,i)=>{i.d(n,{A:()=>s});i(96540);var t=i(18215);const a={tabItem:"tabItem_Ymn6"};var l=i(74848);function s(e){let{children:n,hidden:i,className:s}=e;return(0,l.jsx)("div",{role:"tabpanel",className:(0,t.A)(a.tabItem,s),hidden:i,children:n})}},37244:(e,n,i)=>{i.d(n,{A:()=>y});var t=i(96540),a=i(18215),l=i(44319),s=i(56347),o=i(94280),r=i(73024),c=i(58417),d=i(44031);function u(e){return t.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)((()=>{const e=n??function(e){return u(e).map((e=>{let{props:{value:n,label:i,attributes:t,default:a}}=e;return{value:n,label:i,attributes:t,default:a}}))}(i);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,i])}function b(e){let{value:n,tabValues:i}=e;return i.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:i}=e;const a=(0,s.W6)(),l=function(e){let{queryString:n=!1,groupId:i}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:n,groupId:i});return[(0,r.aZ)(l),(0,t.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(a.location.search);n.set(l,e),a.replace({...a.location,search:n.toString()})}),[l,a])]}function x(e){const{defaultValue:n,queryString:i=!1,groupId:a}=e,l=h(e),[s,r]=(0,t.useState)((()=>function(e){let{defaultValue:n,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!b({value:n,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=i.find((e=>e.default))??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:l}))),[c,u]=p({queryString:i,groupId:a}),[x,m]=function(e){let{groupId:n}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(n),[a,l]=(0,d.Dv)(i);return[a,(0,t.useCallback)((e=>{i&&l.set(e)}),[i,l])]}({groupId:a}),j=(()=>{const e=c??x;return b({value:e,tabValues:l})?e:null})();(0,o.A)((()=>{j&&r(j)}),[j]);return{selectedValue:s,selectValue:(0,t.useCallback)((e=>{if(!b({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);r(e),u(e),m(e)}),[u,m,l]),tabValues:l}}var m=i(46916);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=i(74848);function f(e){let{className:n,block:i,selectedValue:t,selectValue:s,tabValues:o}=e;const r=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.a_)(),d=e=>{const n=e.currentTarget,i=r.indexOf(n),a=o[i].value;a!==t&&(c(n),s(a))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=r.indexOf(e.currentTarget)+1;n=r[i]??r[0];break}case"ArrowLeft":{const i=r.indexOf(e.currentTarget)-1;n=r[i]??r[r.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":i},n),children:o.map((e=>{let{value:n,label:i,attributes:l}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:t===n?0:-1,"aria-selected":t===n,ref:e=>r.push(e),onKeyDown:u,onClick:d,...l,className:(0,a.A)("tabs__item",j.tabItem,l?.className,{"tabs__item--active":t===n}),children:i??n},n)}))})}function v(e){let{lazy:n,children:i,selectedValue:l}=e;const s=(Array.isArray(i)?i:[i]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===l));return e?(0,t.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==l})))})}function T(e){const n=x(e);return(0,g.jsxs)("div",{className:(0,a.A)("tabs-container",j.tabList),children:[(0,g.jsx)(f,{...n,...e}),(0,g.jsx)(v,{...n,...e})]})}function y(e){const n=(0,m.A)();return(0,g.jsx)(T,{...e,children:u(e.children)},String(n))}},58226:(e,n,i)=>{i.d(n,{a:()=>x});var t=i(96540),a=i(72774),l=i(63051),s=i(28968),o=i(48875),r=i(44676),c=i(47859),d=i(4671),u=i(99343),h=i(7324),b=i(39781),p=i(74848);const x=(0,t.memo)((e=>{let{open:n,fullScreen:i=!1,title:o,maxWidth:x="md",onClose:j,children:g}=e;const[f,v]=(0,t.useState)(i),T=(0,t.useCallback)((()=>{v((e=>!e))}),[]);return(0,p.jsxs)(l.A,{open:n,onClose:j,fullScreen:f,TransitionComponent:m,maxWidth:x,children:[(0,p.jsx)(a.A,{sx:{position:"relative"},children:(0,p.jsxs)(r.A,{children:[(0,p.jsx)(c.A,{sx:{ml:2,flex:1},variant:"h6",component:"div",children:o}),(0,p.jsx)(d.A,{onClick:T,style:{color:"white"},children:f?(0,p.jsx)(h.A,{}):(0,p.jsx)(u.A,{})}),(0,p.jsx)(d.A,{"aria-label":"close",onClick:j,style:{color:"white"},children:(0,p.jsx)(b.A,{})})]})}),(0,p.jsx)(s.A,{children:g})]})})),m=t.forwardRef((function(e,n){return(0,p.jsx)(o.A,{direction:"up",ref:n,...e})}))},47389:(e,n,i)=>{i.d(n,{l:()=>o});var t=i(96540),a=i(67512),l=i(58226),s=i(74848);const o=(0,t.memo)((e=>{let{buttonText:n,fullScreen:i=!1,title:o=n,variant:r="outlined",large:c=!1,maxWidth:d,useOriginalText:u=!0,children:h}=e;const[b,p]=(0,t.useState)(!1),x=(0,t.useCallback)((e=>{p(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),m=(0,t.useCallback)((()=>{p(!1)}),[]),j=u?{textTransform:"none"}:{};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.A,{"data-is-view-more-button":"true",onClick:x,variant:r,size:c?"large":"small",style:j,children:n}),(0,s.jsx)(l.a,{open:b,onClose:m,title:o,maxWidth:d,fullScreen:i,children:h})]})}))},52440:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"query/dynamic-join/table-ex","title":"Pagination Safety","description":"Pagination safety is a feature designed for pagination, but table join functionality provides underlying support.","source":"@site/docs/query/dynamic-join/table-ex.mdx","sourceDirName":"query/dynamic-join","slug":"/query/dynamic-join/table-ex","permalink":"/jimmer-doc/docs/query/dynamic-join/table-ex","draft":false,"unlisted":false,"editUrl":"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/dynamic-join/table-ex.mdx","tags":[],"version":"current","lastUpdatedAt":1731427770000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Pagination Safety"},"sidebar":"tutorialSidebar","previous":{"title":"Optimize Unnecessary Joins","permalink":"/jimmer-doc/docs/query/dynamic-join/optimization"},"next":{"title":"Weak Join","permalink":"/jimmer-doc/docs/query/dynamic-join/weak-join"}}');var a=i(74848),l=i(28453),s=i(47389),o=i(37244),r=i(56778);const c={sidebar_position:5,title:"Pagination Safety"},d=void 0,u={},h=[{value:"Problems with Collection Associations",id:"problems-with-collection-associations",level:2},{value:"Collection JOIN Causes Duplicate Results",id:"collection-join-causes-duplicate-results",level:3},{value:"Harms of Duplicate Results",id:"harms-of-duplicate-results",level:3},{value:"Implicit Subqueries",id:"implicit-subqueries",level:2},{value:"Table and TableEx",id:"table-and-tableex",level:2},{value:"Generated Code",id:"generated-code",level:3},{value:"Top-Level Queries Must Be Based on Table",id:"top-level-queries-must-be-based-on-table",level:3},{value:"TableEx Allowed for Subqueries",id:"tableex-allowed-for-subqueries",level:3},{value:"asTableEx",id:"astableex",level:2}];function b(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Pagination safety is a feature designed for pagination, but table join functionality provides underlying support."}),"\n",(0,a.jsx)(n.h2,{id:"problems-with-collection-associations",children:"Problems with Collection Associations"}),"\n",(0,a.jsx)(n.p,{children:"Here, we first introduce two types of associations: reference associations and collection associations."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Associations decorated with ",(0,a.jsx)(n.code,{children:"@OneToOne"})," or ",(0,a.jsx)(n.code,{children:"@ManyToOne"})," are called reference associations."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Associations decorated with ",(0,a.jsx)(n.code,{children:"@OneToMany"})," or ",(0,a.jsx)(n.code,{children:"@ManyToMany"})," are called collection associations."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Please refer to the example:"}),"\n",(0,a.jsxs)(s.l,{buttonText:"Association example",children:[(0,a.jsx)(n.p,{children:"Let's look at this entity definition:"}),(0,a.jsxs)(o.A,{groupId:"language",children:[(0,a.jsx)(r.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Book.java"',children:'\npackage org.babyfish.jimmer.sql.example.model;\n\nimport java.math.BigDecimal;\nimport java.util.List;\nimport javax.validation.constraints.Null;\n\nimport org.babyfish.jimmer.sql.*;\n\n@Entity\npublic interface Book {\n\n    @Id\n    long id();\n\n    String name();\n\n    int edition();\n\n    BigDecimal price();\n\n    @Null\n    @ManyToOne\n    // highlight-next-line\n    BookStore store();\n\n    @ManyToMany\n    @JoinTable(\n            name = "BOOK_AUTHOR_MAPPING",\n            joinColumnName = "BOOK_ID",\n            inverseJoinColumnName = "AUTHOR_ID"\n    )\n    // highlight-next-line\n    List<Author> authors();\n}\n'})})}),(0,a.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",metastring:'title="Book.kt"',children:'\npackage org.babyfish.jimmer.sql.example.model\n\nimport java.math.BigDecimal;\n\nimport org.babyfish.jimmer.sql.*;\n\n@Entity\ninterface Book {\n\n    @Id\n    val id: Long\n\n    val name: String\n\n    val edition: Int\n\n    val price: BigDecimal\n\n    @ManyToOne\n    // highlight-next-line\n    val store: BookStore?\n\n    @ManyToMany\n    @JoinTable(\n            name = "BOOK_AUTHOR_MAPPING",\n            joinColumnName = "BOOK_ID",\n            inverseJoinColumnName = "AUTHOR_ID"\n    )\n    // highlight-next-line\n    val authors: List<Author>\n}\n'})})})]}),(0,a.jsx)(n.p,{children:"In this example:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Book.store"})," decorated with ",(0,a.jsx)(n.code,{children:"@ManyToOne"})," is a reference association."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Book.authors"})," decorated with ",(0,a.jsx)(n.code,{children:"@ManyToMany"})," is a collection association."]}),"\n"]})]}),"\n",(0,a.jsx)(n.h3,{id:"collection-join-causes-duplicate-results",children:"Collection JOIN Causes Duplicate Results"}),"\n",(0,a.jsx)(n.p,{children:"If we call the entity object corresponding to the first table being queried the aggregate root object, reference associations and collection associations differ in:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Joining tables via a reference association does not produce duplicate records of the current main object in the SQL query result. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select \n    b.id as root_id,\n    b.name as root_name,\n    s.id as associated_id,\n    s.name as associated_name\nfrom book b\ninner join book_store s\n    on b.store_id = s.id\nwhere b.id = 1;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The query result has no duplicate aggregate root objects:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"root_id"}),(0,a.jsx)(n.th,{children:"root_name"}),(0,a.jsx)(n.th,{children:"associated_id"}),(0,a.jsx)(n.th,{children:"associated_name"})]})}),(0,a.jsx)(n.tbody,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"Learning GraphQL"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"O'REILLY"})]})})]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Joining tables via a collection association produces duplicate records of the current main object in the SQL query result:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select\n    b.id as root_id, \n    b.name as root_name,\n    a.id as associated_id,\n    a.first_name as associated_first_name,\n    a.last_name as associated_last_name\nfrom book b\ninner join book_author_mapping m\n    on b.id = m.book_id \ninner join author a\n    on m.author_id = a.id\nwhere b.id = 1;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Query result may have duplicate aggregate root objects:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"root_id"}),(0,a.jsx)(n.th,{children:"root_name"}),(0,a.jsx)(n.th,{children:"associated_id"}),(0,a.jsx)(n.th,{children:"associated_first_name"}),(0,a.jsx)(n.th,{children:"associated_last_name"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"Learning GraphQL"}),(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"Eve"}),(0,a.jsx)(n.td,{children:"Procello"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:"Learning GraphQL"}),(0,a.jsx)(n.td,{children:"2"}),(0,a.jsx)(n.td,{children:"Alex"}),(0,a.jsx)(n.td,{children:"Banks"})]})]})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"harms-of-duplicate-results",children:"Harms of Duplicate Results"}),"\n",(0,a.jsx)(n.p,{children:"Table joins based on collection associations lead to duplicate data, which causes the following problems:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Bugs if the developer forgets deduplication."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Even if the developer does not forget deduplication, using ",(0,a.jsx)(n.code,{children:"java.util.LinkedHashSet"})," for deduplication post factum is not ideal."]}),"\n",(0,a.jsx)(n.p,{children:"Because the fact that the original database result contains duplicates cannot be altered, and extra network transfer and JVM data processing costs are incurred."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Most importantly, unfriendly to pagination queries"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Paginating table join results at the SQL level is often not what people want. More often, people want pagination applied on aggregate root objects."}),"\n",(0,a.jsx)(n.p,{children:"Take Hibernate for example. In this case, Hibernate has to abandon SQL-level pagination and use memory-level pagination instead. This performs very poorly that Hibernate logs a warning to alert developers. If you have experience with Hibernate, the log below would give you a headache:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://tech.asimio.net/2021/05/19/Fixing-Hibernate-HHH000104-firstResult-maxResults-warning-using-Spring-Data-JPA.html",children:"firstResult/maxResults specified with collection fetch; applying in memory"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Note that Jimmer's other feature ",(0,a.jsx)(n.a,{href:"../object-fetcher",children:"Object Fetcher"})," does not use table join to fetch collection associations, so it does not have this problem. Feel free to use it."]})}),"\n",(0,a.jsx)(n.p,{children:"In summary, using collection joins in top-level queries has obvious drawbacks, but it remains valuable to use collection joins in subqueries."}),"\n",(0,a.jsx)(n.p,{children:"Therefore, Jimmer SQL DSL has the following characteristics:"}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Table joins based on collection associations are ",(0,a.jsx)(n.strong,{children:"prohibited"})," in ",(0,a.jsx)(n.strong,{children:"top-level"})," queries."]}),"\n",(0,a.jsx)(n.li,{children:"Table joins based on collection associations remain allowed in subqueries, update statements and delete statements."}),"\n"]})}),"\n",(0,a.jsx)(n.h2,{id:"implicit-subqueries",children:"Implicit Subqueries"}),"\n",(0,a.jsxs)(n.admonition,{type:"tip",children:[(0,a.jsxs)(n.p,{children:["For collection associations, JOIN is actually not recommended. ",(0,a.jsx)(n.a,{href:"../implicit-subquery",children:"Implicit subqueries"})," are more recommended."]}),(0,a.jsx)(n.p,{children:"If you still want to JOIN collection association properties, please continue reading below."})]}),"\n",(0,a.jsx)(n.h2,{id:"table-and-tableex",children:"Table and TableEx"}),"\n",(0,a.jsxs)(n.p,{children:["There are two kinds of table objects in Jimmer SQL DSL, ",(0,a.jsx)(n.code,{children:"Table<E>"})," and ",(0,a.jsx)(n.code,{children:"TableEx<E>"}),"."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Table"}),"\n",(0,a.jsx)(n.p,{children:"Features: Can only join via reference associations, cannot join via collection associations."}),"\n",(0,a.jsx)(n.p,{children:"Java type: org.babyfish.jimmer.sql.ast.table.Table<E>"}),"\n",(0,a.jsx)(n.p,{children:"Kotlin type: org.babyfish.jimmer.sql.kt.ast.table.KTable<E>"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"TableEx"}),"\n",(0,a.jsx)(n.p,{children:"Features: Can join via any associations."}),"\n",(0,a.jsx)(n.p,{children:"Java type: org.babyfish.jimmer.sql.ast.table.TableEx<E>"}),"\n",(0,a.jsx)(n.p,{children:"Kotlin type: org.babyfish.jimmer.sql.kt.ast.table.KTableEx<E>"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"generated-code",children:"Generated Code"}),"\n",(0,a.jsx)(n.p,{children:"To implement strongly typed SQL DSL, Jimmer uses Annotation Processor (Java) or KSP (Kotlin) to generate SQL DSL related source code based on user-defined entity interfaces."}),"\n",(0,a.jsx)(n.p,{children:"Take the Book entity interface at the beginning of this article as an example. The following two types would be generated automatically:"}),"\n",(0,a.jsxs)(o.A,{groupId:"language",children:[(0,a.jsx)(r.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",metastring:'title="Generated Java Code" ',children:'/*\n * BookTable.java \n */\npackage org.babyfish.jimmer.sql.example.model;\n\nimport java.lang.Integer;\nimport java.math.BigDecimal;\nimport javax.persistence.criteria.JoinType;\nimport org.babyfish.jimmer.sql.ast.Expression;\nimport org.babyfish.jimmer.sql.ast.PropExpression;\nimport org.babyfish.jimmer.sql.ast.table.Table;\nimport org.babyfish.jimmer.sql.ast.table.spi.AbstractTableWrapper;\n\npublic class BookTable extends AbstractTableWrapper<Book> {\n    public BookTable(Table<Book> table) {\n        super(table);\n    }\n\n    public Expression<Long> id() {\n        return get("id");\n    }\n\n    public PropExpression.Str name() {\n        return get("name");\n    }\n\n    public PropExpression.Num<Integer> edition() {\n        return get("edition");\n    }\n\n    public PropExpression.Num<BigDecimal> price() {\n        return get("price");\n    }\n\n    public BookStoreTable store() {\n        return join("store");\n    }\n\n    public BookStoreTable store(JoinType joinType) {\n        return join("store", joinType);\n    }\n}\n\n/*\n * BookTableEx.java\n */ \npackage org.babyfish.jimmer.sql.example.model;\n\nimport javax.persistence.criteria.JoinType;\nimport org.babyfish.jimmer.sql.ast.table.TableEx;\n\npublic class BookTableEx extends BookTable implements TableEx<Book> {\n    public BookTableEx(TableEx<Book> table) {\n        super(table);\n    }\n\n    public AuthorTableEx authors() {\n        return join("authors");\n    }\n\n    public AuthorTableEx authors(JoinType joinType) {\n        return join("authors", joinType);\n    }\n}\n'})})}),(0,a.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",metastring:'title="Generated Kotlin Code"',children:'package org.babyfish.jimmer.example.kt.sql.model\n\nimport java.math.BigDecimal\nimport org.babyfish.jimmer.sql.ast.Selection\nimport org.babyfish.jimmer.sql.kt.ast.expression.KNonNullPropExpression\nimport org.babyfish.jimmer.sql.kt.ast.expression.KNullablePropExpression\nimport org.babyfish.jimmer.sql.kt.ast.table.KNonNullTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KNonNullTableEx\nimport org.babyfish.jimmer.sql.kt.ast.table.KNullableTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KNullableTableEx\nimport org.babyfish.jimmer.sql.kt.ast.table.KTable\nimport org.babyfish.jimmer.sql.kt.ast.table.KTableEx\n\n/*\n * Extension for Table<Book>  \n */\npublic val KTable<Book>.id: KNullablePropExpression<Long>\n    get() = get("id")\n\npublic val KNonNullTable<Book>.id: KNonNullPropExpression<Long>\n    get() = get("id")\n\npublic val KTable<Book>.name: KNullablePropExpression<String>\n    get() = get("name")\n\npublic val KNonNullTable<Book>.name: KNonNullPropExpression<String>\n    get() = get("name")\n\npublic val KTable<Book>.edition: KNullablePropExpression<Int>\n    get() = get("edition")\n\npublic val KNonNullTable<Book>.edition: KNonNullPropExpression<Int>\n    get() = get("edition")\n\npublic val KTable<Book>.price: KNullablePropExpression<BigDecimal>\n    get() = get("price")\n\npublic val KNonNullTable<Book>.price: KNonNullPropExpression<BigDecimal>\n    get() = get("price")\n\npublic val KNullableTable<Book>.store: KNullableTable<BookStore>\n    get() = join("store")\n\npublic val KNonNullTable<Book>.store: KNonNullTable<BookStore>\n    get() = join("store")\n\npublic val KTable<Book>.`store?`: KNullableTable<BookStore>\n    get() = outerJoin("store")\n\n/*\n * Extension for TableEx<Book>\n */\n\npublic val KNullableTableEx<Book>.authors: KNullableTableEx<Author>\n    get() = join("authors")\n\npublic val KNonNullTableEx<Book>.authors: KNonNullTableEx<Author>\n    get() = join("authors")\n\npublic val KTableEx<Book>.`authors?`: KNullableTableEx<Author>\n    get() = outerJoin("authors")\n'})})})]}),"\n",(0,a.jsx)(n.p,{children:"Observing the two auto-generated types, we can see:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"BookTableEx"})," inherits ",(0,a.jsx)(n.code,{children:"BookTable"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"BookTable"})," does not support collection associations, but supports regular fields and reference associations (which is ",(0,a.jsx)(n.code,{children:"store"})," in this example)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"BookTableEx"})," adds support for collection associations (which is ",(0,a.jsx)(n.code,{children:"authors"})," in this example)."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Therefore, jimmer-sql API follows this pattern:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Top-level queries can only be created based on ",(0,a.jsx)(n.code,{children:"Table"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Subqueries, update statements and delete statements can be created based on either ",(0,a.jsx)(n.code,{children:"Table"})," or ",(0,a.jsx)(n.code,{children:"TableEx"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Next, we demonstrate the contrast between top-level queries and subqueries with examples."}),"\n",(0,a.jsx)(n.h3,{id:"top-level-queries-must-be-based-on-table",children:"Top-Level Queries Must Be Based on Table"}),"\n",(0,a.jsx)(n.p,{children:"So your code looks like:"}),"\n",(0,a.jsxs)(o.A,{groupId:"language",children:[(0,a.jsx)(r.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'BookTable table = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(\n        table\n            // highlight-next-line\n            .name() // Can access regular field name  \n            .eq("Book Name")\n    )\n    .where(\n        table\n            // highlight-next-line \n            .store() // Can also join reference association store\n            .name()\n            .eq("Store Name")\n    )\n    /*\n     * However, cannot use "table.authors()" because `authors()`\n     * is defined in `BookTableEx` instead of `BookTable`.\n     *  \n     * That is, joining collection associations is prohibited  \n     * at compile time in top-level queries.\n     */ \n    .select(table)\n    .execute();\n'})})}),(0,a.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                // highlight-next-line\n                .name // Can access regular field name\n                eq "Book Name" \n        )\n        where(\n            table\n                // highlight-next-line\n                .store // Can also join reference association `store`\n                .name\n                eq "Store Name"\n        )\n        /*\n         * However, cannot use "table.authors" because the extension property `authors`\n         * is defined on `TableEx<Book>` instead of `Table<Book>`.\n         *  \n         * That is, joining collection associations is prohibited \n         * at compile time in top-level queries.\n         */\n        select(table)\n    }\n    .execute()\n'})})})]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Java: ",(0,a.jsx)(n.code,{children:"createQuery"})," takes parameter specified by user, can only be ",(0,a.jsx)(n.code,{children:"Table"})," type. ",(0,a.jsx)(n.code,{children:"TableEx"})," would error."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Kotlin: ",(0,a.jsx)(n.code,{children:"createQuery"})," creates table object automatically. The automatic variable ",(0,a.jsx)(n.code,{children:"table"})," in lambda is inferred to ",(0,a.jsx)(n.code,{children:"Table"})," instead of ",(0,a.jsx)(n.code,{children:"TableEx"}),"."]}),"\n"]}),"\n"]})}),"\n",(0,a.jsx)(n.p,{children:"The final generated SQL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\ninner join BOOK_STORE as tb_2_ on tb_1_.STORE_ID = tb_2_.ID\nwhere\n    tb_1_.NAME = ?\nand \n    tb_2_.NAME = ? \n"})}),"\n",(0,a.jsx)(n.h3,{id:"tableex-allowed-for-subqueries",children:"TableEx Allowed for Subqueries"}),"\n",(0,a.jsx)(n.p,{children:"Unlike top-level queries, subqueries, update statements and delete statements allow TableEx."}),"\n",(0,a.jsxs)(n.p,{children:["In the example below, ",(0,a.jsx)(n.code,{children:"Author.books"})," is the same as ",(0,a.jsx)(n.code,{children:"Book.authors"})," discussed above, which is also a many-to-many association."]}),"\n",(0,a.jsxs)(o.A,{groupId:"language",children:[(0,a.jsx)(r.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'BookTable table = Tables.BOOK_TABLE;\n\n// `author` used in subquery, use TableEx\nAuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(sqlClient\n        // highlight-next-line\n        .createSubQuery(author)\n        .where(\n            author\n                // `author` is TableEx, \n                // so collection association `books` is allowed\n                // highlight-next-line\n                .books()\n                .eq(table),\n\n            author.firstName().eq("Alex")\n        )\n        .exists()\n    )\n    .select(table)\n    .execute();\n'})})}),(0,a.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val books = sqlClient\n    .createQuery(Book::class) {\n\n        // In parent query `table` is Table<Book>\n        \n        where(\n            exists(\n                // highlight-next-line\n                wildSubQuery(Author::class) {\n\n                    // Subquery's `table` overrides parent's `table`,\n                    // and the Subquery's `table` is `TableEx<Author>`\n                    \n                    where(\n                        table\n                            // Subquery's `table` is TableEx,\n                            // so collection association `books` is allowed\n                            // highlight-next-line\n                            .books eq\n                            parentTable,\n\n                        table.firstName.eq(\"Alex\")\n                    )\n                }\n            )\n        )\n        select(table)\n    }\n    .execute()\n"})})})]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Java: ",(0,a.jsx)(n.code,{children:"createSubQuery"})," takes parameter specified by user, not enforced but suggested to be ",(0,a.jsx)(n.code,{children:"TableEx"})," type."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["Kotlin: ",(0,a.jsx)(n.code,{children:"wildSubQuery"})," ",(0,a.jsxs)(n.em,{children:["(or ",(0,a.jsx)(n.code,{children:"subQuery"}),")"]})," creates table object automatically. The automatic variable ",(0,a.jsx)(n.code,{children:"table"})," in lambda is inferred to ",(0,a.jsx)(n.code,{children:"TableEx"})," instead of ",(0,a.jsx)(n.code,{children:"Table"}),"."]}),"\n"]}),"\n"]})}),"\n",(0,a.jsx)(n.p,{children:"The final generated SQL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere exists(\n    select 1\n    from AUTHOR as tb_2_\n    // highlight-start\n    inner join BOOK_AUTHOR_MAPPING as tb_3_\n        on tb_2_.ID = tb_3_.AUTHOR_ID\n    // highlight-end\n    where\n        tb_3_.BOOK_ID = tb_1_.ID\n    and\n        tb_2_.FIRST_NAME = ?\n)  \n"})}),"\n",(0,a.jsx)(n.h2,{id:"astableex",children:"asTableEx"}),"\n",(0,a.jsx)(n.p,{children:"Prohibiting collection associations in top-level queries is reasonable in most cases, but not all cases."}),"\n",(0,a.jsxs)(n.p,{children:["For example, the user does not query entire objects, but individual fields, and uses the SQL keyword ",(0,a.jsx)(n.code,{children:"distinct"})," to offset the side effects of joining collection associations. This scenario is perfectly reasonable."]}),"\n",(0,a.jsx)(n.p,{children:"Therefore, prohibiting collection associations in top-level queries is a soft constraint rather than a hard constraint. It can be easily overridden."}),"\n",(0,a.jsxs)(o.A,{groupId:"language",children:[(0,a.jsx)(r.A,{value:"java",label:"Java",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'BookTable book = Tables.BOOK_TABLE;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx() \u2776\n            .authors()\n            .firstName()\n            .ilike("A%")\n    )\n    .select(book.id()) \n    .distinct() \u2777\n    .execute();\n'})})}),(0,a.jsx)(r.A,{value:"kotlin",label:"Kotlin",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx() \u2776\n                .authors\n                .firstName ilike "A%"\n        )\n        select(table.id)\n    }\n    .distinct() \u2777\n    .execute()\n'})})})]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"\u2776 The developer informs Jimmer that they know what they are doing, asking Jimmer to allow joining collection associations."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["\u2777 The developer takes responsibility for their own actions. If there are additional operations here, it should be ",(0,a.jsx)(n.code,{children:"distinct"})," rather than pagination related."]}),"\n"]}),"\n"]})}),"\n",(0,a.jsx)(n.p,{children:"The final generated SQL:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_\n/* highlight-start */  \ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID\ninner join AUTHOR as tb_3_\n    on tb_2_.AUTHOR_ID = tb_3_.ID\n/* highlight-end */\nwhere lower(tb_3_.FIRST_NAME) like ?\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(96540);const a={},l=t.createContext(a);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);