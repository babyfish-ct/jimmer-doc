"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[5547],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,b=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(b,r(r({ref:t},u),{},{components:n})):a.createElement(b,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(67294),o=n(34334);const i="tabItem_Ymn6";function r(e){let{children:t,hidden:n,className:r}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(i,r),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(83117),o=n(67294),i=n(34334),r=n(72389),l=n(67392),s=n(7094),c=n(12466);const u="tabList__CuJ",p="tabItem_LNqP";function d(e){var t;const{lazy:n,block:r,defaultValue:d,values:m,groupId:b,className:h}=e,k=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),y=m??k.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),g=(0,l.l)(y,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===d?d:d??(null==(t=k.find((e=>e.props.default)))?void 0:t.props.value)??k[0].props.value;if(null!==f&&!y.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${y.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:T,setTabGroupChoices:N}=(0,s.U)(),[_,v]=(0,o.useState)(f),O=[],{blockElementScrollPositionUntilNextRender:A}=(0,c.o5)();if(null!=b){const e=T[b];null!=e&&e!==_&&y.some((t=>t.value===e))&&v(e)}const x=e=>{const t=e.currentTarget,n=O.indexOf(t),a=y[n].value;a!==_&&(A(t),v(a),null!=b&&N(b,String(a)))},I=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=O.indexOf(e.currentTarget)+1;n=O[t]??O[0];break}case"ArrowLeft":{const t=O.indexOf(e.currentTarget)-1;n=O[t]??O[O.length-1];break}}null==(t=n)||t.focus()};return o.createElement("div",{className:(0,i.Z)("tabs-container",u)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":r},h)},y.map((e=>{let{value:t,label:n,attributes:r}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:_===t?0:-1,"aria-selected":_===t,key:t,ref:e=>O.push(e),onKeyDown:I,onFocus:x,onClick:x},r,{className:(0,i.Z)("tabs__item",p,null==r?void 0:r.className,{"tabs__item--active":_===t})}),n??t)}))),n?(0,o.cloneElement)(k.filter((e=>e.props.value===_))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},k.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==_})))))}function m(e){const t=(0,r.Z)();return o.createElement(d,(0,a.Z)({key:String(t)},e))}},83511:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var a=n(83117),o=(n(67294),n(3905)),i=n(65488),r=n(85162);const l={sidebar_position:13,title:"Querying Association Tables"},s=void 0,c={unversionedId:"query/associations",id:"query/associations",title:"Querying Association Tables",description:"Association Tables Hidden by Object Model",source:"@site/docs/query/associations.mdx",sourceDirName:"query",slug:"/query/associations",permalink:"/jimmer-doc/docs/query/associations",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/associations.mdx",tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13,title:"Querying Association Tables"},sidebar:"tutorialSidebar",previous:{title:"Logical Deletion",permalink:"/jimmer-doc/docs/query/global-filter/logical-deleted"},next:{title:"Super QBE",permalink:"/jimmer-doc/docs/query/super_qbe"}},u={},p=[{value:"Association Tables Hidden by Object Model",id:"association-tables-hidden-by-object-model",level:2},{value:"Querying Association Tables Directly",id:"querying-association-tables-directly",level:2},{value:"Comparison with Entity Table Queries",id:"comparison-with-entity-table-queries",level:2},{value:"1. Use association table subquery to achieve a function",id:"1-use-association-table-subquery-to-achieve-a-function",level:3},{value:"2. Achieve the same functionality with entity table subquery",id:"2-achieve-the-same-functionality-with-entity-table-subquery",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"association-tables-hidden-by-object-model"},"Association Tables Hidden by Object Model"),(0,o.kt)("p",null,"Let's review this piece of entity interface code:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Entity\npublic interface Book {\n\n    @ManyToMany\n    @JoinTable(\n        // highlight-next-line  \n        name = "BOOK_AUTHOR_MAPPING",  \n        joinColumnName = "BOOK_ID",  \n        inverseJoinColumnName = "AUTHOR_ID"\n    )\n    List<Author> authors();\n\n    ...omit other code...\n}\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Entity\ninterface Book {\n\n    @ManyToMany\n    @JoinTable(\n        // highlight-next-line\n        name = "BOOK_AUTHOR_MAPPING",\n        joinColumnName = "BOOK_ID",\n        inverseJoinColumnName = "AUTHOR_ID" \n    )\n    val authors: List<Author>\n\n    ...omit other code...\n}\n')))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table is used as an association table here.  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK")," table in the database has a corresponding Book entity interface in Java code.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTHOR")," table in the database has a corresponding Author entity interface in Java code.  ")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"However, the ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table in the database does not have a corresponding entity interface in Java code."))),(0,o.kt)("p",null,"That is, the association table is hidden from the object model."),(0,o.kt)("h2",{id:"querying-association-tables-directly"},"Querying Association Tables Directly"),(0,o.kt)("p",null,"Jimmer provides an interesting feature that allows querying association tables directly even if they are hidden without corresponding entities."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"AssociationTable<Book, BookTableEx, Author, AuthorTableEx> association =\n    AssociationTable.of(BookTableEx.class, BookTableEx::authors);\n    \nList<Association<Book, Author>> associations = \n    sqlClient\n        // highlight-next-line\n        .createAssociationQuery(association)\n        .where(association.source().id().eq(3L))\n        .select(association)\n        .execute();\nassociations.forEach(System.out::println);\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val associations = sqlClient\n    .queries\n    .forList(Book::authors) {\n        where(table.source.id eq 3L)\n        select(table)\n    }\n    .execute()\nassociations.forEach(::println) \n")))),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"createAssociationQuery")," in Java or ",(0,o.kt)("inlineCode",{parentName:"p"},"queries.forList")," in Kotlin represents a query based on the association table instead of entity tables.  "),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The Java code demo here uses ",(0,o.kt)("inlineCode",{parentName:"p"},"AssociationTable")," type with complex generic arguments to be compatible with Java 8. It is recommended to upgrade Java and use the ",(0,o.kt)("inlineCode",{parentName:"p"},"var")," keyword.")),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, \n    tb_1_.AUTHOR_ID  \n/* highlight-next-line */\nfrom BOOK_AUTHOR_MAPPING as tb_1_\nwhere tb_1_.BOOK_ID = ? /* 3 */\n")),(0,o.kt)("p",null,"This is indeed a query based on the association table."),(0,o.kt)("p",null,"The final printed result is (the original output is compact, formatted here for readability):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Association{\n    source={\n        "id":3\n    }, target={\n        "id":1\n    }\n}\nAssociation{ \n    source={\n        "id":3\n    },\n    target={\n        "id":2\n    }\n}\n')),(0,o.kt)("p",null,"The returned data is a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"Association")," objects:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class Association<S, T> {\n\n    public S source;\n    public T target;\n\n    // constructor and getter/setters\n} \n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Association<S, T>")," represents association table entities that associate ",(0,o.kt)("inlineCode",{parentName:"p"},"S")," type to ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," type. Association table entities are pseudo entities without ids. They only have two properties:  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"source"),": The object (Book in this example) corresponding to the foreign key pointing to the owning side.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"target"),": The object (Author in this example) corresponding to the foreign key pointing to the target side."))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In this example, object fetchers are not used to define the format of association pseudo entity objects (in fact association pseudo entity does not support object fetchers), so the ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," association properties only contain id property.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"Author")," also has a bidirectional many-to-many association ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.books"),", which is the mirror of ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.authors"),"."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Entity  \npublic interface Author {\n\n    // highlight-next-line\n    @ManyToMany(mappedBy = "authors")\n    List<Book> books();\n\n    ...\n}\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Entity\ninterface Author {\n\n    // highlight-next-line\n    @ManyToMany(mappedBy = "authors") \n    val books: List<Book>\n\n    ...\n}\n')))),(0,o.kt)("p",{parentName:"li"},"Association table queries can also be created based on ",(0,o.kt)("inlineCode",{parentName:"p"},"Author.books"),", but ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," will represent Author and ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," will represent Book, reversed from the current example.  ")))),(0,o.kt)("p",null,"In this example, we only query the association table itself, so ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," objects only contain ids. "),(0,o.kt)("p",null,"To get complete ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," objects, join tables and use tuples for return:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"AssociationTable<Book, BookTableEx, Author, AuthorTableEx> association =\n    AssociationTable.of(BookTableEx.class, BookTableEx::authors);\n\nList<Tuple2<Book, Author>> tuples =  \n    sqlClient\n        .createAssociationQuery(association)\n        .where(association.source().id().eq(3L))\n        // highlight-next-line\n        .select(\n            association.source(),\n            association.target() \n        )\n        .execute();\ntuples.forEach(System.out::println);\n"))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val associations = sqlClient\n    .queries\n    .forList(Book::authors) {\n        where(table.source.id eq 3L)\n        // highlight-next-line\n        select(\n            table.source,\n            table.target\n        )\n    }\n    .execute()\nassociations.forEach(::println)\n")))),(0,o.kt)("p",null,"The generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    /* source() */\n    tb_1_.BOOK_ID,\n    tb_2_.NAME,\n    tb_2_.EDITION,\n    tb_2_.PRICE,\n    tb_2_.STORE_ID,\n\n    /* target() */ \n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME,\n    tb_3_.GENDER\n\nfrom BOOK_AUTHOR_MAPPING as tb_1_  \ninner join BOOK as tb_2_\n    on tb_1_.BOOK_ID = tb_2_.ID\ninner join AUTHOR as tb_3_\n    on tb_1_.AUTHOR_ID = tb_3_.ID\nwhere tb_1_.BOOK_ID = ? /* 3 */ \n")),(0,o.kt)("p",null,"The final printed result is (formatted for readability):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Tuple2{\n    _1={\n        "id": 3,\n        "name": "Learning GraphQL", \n        "edition": 3,\n        "price": 51.00,\n        "store": {\n            "id": 1\n        }\n    },\n    _2={\n        "id": 1,\n        "firstName": "Alex",\n        "lastName": "Banks",\n        "gender": "MALE"\n    }\n} \nTuple2{\n    _1={\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        "store": {\n            "id": 1\n        }\n    },\n    _2={\n        "id": 2, \n        "firstName": "Eve",\n        "lastName": "Procello",\n        "gender": "MALE" \n    }\n}\n')),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The association pseudo entity ",(0,o.kt)("inlineCode",{parentName:"p"},"Association<S, T>")," is simple and special, does not support or need ",(0,o.kt)("a",{parentName:"p",href:"./object-fetcher"},"object fetchers"),".  "),(0,o.kt)("p",{parentName:"admonition"},"However, its association properties ",(0,o.kt)("inlineCode",{parentName:"p"},"source")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," can support ",(0,o.kt)("a",{parentName:"p",href:"./object-fetcher"},"object fetchers"),", such as:"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"select(\n    table\n        .source\n        // highlight-next-line\n        .fetchBy {\n            allScalarFields()\n            store {\n                allScalarFields() \n            }\n        },\n    table.target\n)\n"))))),(0,o.kt)("h2",{id:"comparison-with-entity-table-queries"},"Comparison with Entity Table Queries"),(0,o.kt)("p",null,"Readers may think that association table queries exist to allow developers to write more performant queries."),(0,o.kt)("p",null,"But this is not the case. Due to optimizations like ",(0,o.kt)("a",{parentName:"p",href:"./dynamic-join/optimization#phantom-joins"},"phantom joins")," and ",(0,o.kt)("a",{parentName:"p",href:"./dynamic-join/optimization#half-joins"},"half joins"),", whether association table queries are used or not, similar functionality and performance can be achieved. Using association table queries is completely up to user preference."),(0,o.kt)("h3",{id:"1-use-association-table-subquery-to-achieve-a-function"},"1. Use association table subquery to achieve a function"),(0,o.kt)("p",null,"In previous examples, we demoed top-level queries based on association tables. Here we demo an association table subquery."),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable table = Tables.BOOK_TABLE;\nAssociationTable<Book, BookTableEx, Author, AuthorTableEx> association =\n    AssociationTable.of(BookTableEx.class, BookTableEx::authors);\n\nList<Book> books = sqlClient\n    .createQuery(table)\n    .where(\n        table.id().in(\n            // highlight-next-line\n            sqlClient\n                .createAssociationSubQuery(association) \n                .where(\n                    association\n                        .target() \u2776\n                        .firstName().eq("Alex")\n                )\n                .select(\n                    association\n                        .source() \u2777\n                        .id()\n                )\n        )  \n    )\n    .select(table)\n    .execute();\n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table.id valueIn\n                // highlight-next-line\n                subQueries.forList(Book::authors) {\n                    where(\n                        table\n                        .target \u2776\n                        .firstName eq "Alex"\n                    )\n                    select(\n                        table\n                        .source \u2777\n                        .id\n                    ) \n                }\n        )\n        select(table)\n    }\n    .execute()\n')))),(0,o.kt)("p",null,"Where:  "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"createAssociationSubQuery")," in Java and ",(0,o.kt)("inlineCode",{parentName:"p"},"subQueries.forList")," in Kotlin create a subquery based on the association table, to find books that contain the author with ",(0,o.kt)("inlineCode",{parentName:"p"},"firstName"),' "Alex".')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2776 ",(0,o.kt)("inlineCode",{parentName:"p"},"association.target")," is a real JOIN that generates SQL JOIN to the ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTHOR")," table for condition check.  ")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"\u2777 ",(0,o.kt)("inlineCode",{parentName:"p"},"association.source")," is a ",(0,o.kt)("a",{parentName:"p",href:"./dynamic-join/optimization#phantom-joins"},"phantom join")," that does not generate a SQL join."))),(0,o.kt)("p",null,"The final generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME, \n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_  \nwhere\n    tb_1_.ID in (\n        /* highlight-next-line */ \n        select\n            tb_2_.BOOK_ID\n        from BOOK_AUTHOR_MAPPING as tb_2_\n        inner join AUTHOR as tb_3_\n            on tb_2_.AUTHOR_ID = tb_3_.ID\n        where tb_3_.FIRST_NAME = ? \n    )\n")),(0,o.kt)("h3",{id:"2-achieve-the-same-functionality-with-entity-table-subquery"},"2. Achieve the same functionality with entity table subquery"),(0,o.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\nAuthorTableEx author = TableExes.AUTHOR_TABLE_EX;\n\nList<Book> books = sqlClient\n    .createQuery(book) \n    .where(\n        book.id().in(sqlClient\n            // highlight-next-line\n            .createSubQuery(author)\n            .where(author.firstName().eq("Alex"))\n            .select(\n                author.books().id() \u2776\n            )\n        )\n    )\n    .select(book)\n    .execute(); \n'))),(0,o.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table.id valueIn\n                // highlight-next-line\n                subQuery(Author::class) {\n                    where(table.firstName eq "Alex")\n                    select(\n                        table.books.id \u2776\n                    )\n                }\n        )\n        select(table)\n    }\n    .execute()\n')))),(0,o.kt)("p",null,"\u2776  ",(0,o.kt)("inlineCode",{parentName:"p"},"author.books")," is a ",(0,o.kt)("a",{parentName:"p",href:"./dynamic-join/optimization#half-joins"},"half join")," that only generates SQL JOIN from ",(0,o.kt)("inlineCode",{parentName:"p"},"AUTHOR")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table, without further join to the ",(0,o.kt)("inlineCode",{parentName:"p"},"BOOK")," table."),(0,o.kt)("p",null,"The final generated SQL is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION, \n    tb_1_.PRICE,\n    tb_1_.STORE_ID\n    \nfrom BOOK as tb_1_\nwhere\n    tb_1_.ID in (\n        /* highlight-next-line */\n        select\n            tb_3_.BOOK_ID\n        from AUTHOR as tb_2_\n        inner join BOOK_AUTHOR_MAPPING as tb_3_\n            on tb_2_.ID = tb_3_.AUTHOR_ID\n        where tb_2_.FIRST_NAME = ?\n    ) \n")),(0,o.kt)("p",null,"Comparing the two SQLs, it's not hard to see they achieve the same functionality and performance.  "),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Association table queries just provide developers with another query style, they are not irreplaceable. The same functionality and performance can be achieved with other means.")))}m.isMDXComponent=!0}}]);