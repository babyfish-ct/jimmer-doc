"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[3350],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=s(a),u=i,k=d["".concat(p,".").concat(u)]||d[u]||m[u]||l;return a?n.createElement(k,o(o({ref:t},c),{},{components:a})):n.createElement(k,o({ref:t},c))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,o=new Array(l);o[0]=d;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var s=2;s<l;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},85162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(67294),i=a(34334);const l="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,i.Z)(l,o),hidden:a},t)}},65488:(e,t,a)=>{a.d(t,{Z:()=>u});var n=a(83117),i=a(67294),l=a(34334),o=a(72389),r=a(67392),p=a(7094),s=a(12466);const c="tabList__CuJ",m="tabItem_LNqP";function d(e){var t;const{lazy:a,block:o,defaultValue:d,values:u,groupId:k,className:g}=e,N=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=u??N.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),b=(0,r.l)(f,((e,t)=>e.value===t.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const h=null===d?d:d??(null==(t=N.find((e=>e.props.default)))?void 0:t.props.value)??N[0].props.value;if(null!==h&&!f.some((e=>e.value===h)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${h}" but none of its children has the corresponding value. Available values are: ${f.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:v}=(0,p.U)(),[_,T]=(0,i.useState)(h),S=[],{blockElementScrollPositionUntilNextRender:B}=(0,s.o5)();if(null!=k){const e=y[k];null!=e&&e!==_&&f.some((t=>t.value===e))&&T(e)}const I=e=>{const t=e.currentTarget,a=S.indexOf(t),n=f[a].value;n!==_&&(B(t),T(n),null!=k&&v(k,String(n)))},O=e=>{var t;let a=null;switch(e.key){case"ArrowRight":{const t=S.indexOf(e.currentTarget)+1;a=S[t]??S[0];break}case"ArrowLeft":{const t=S.indexOf(e.currentTarget)-1;a=S[t]??S[S.length-1];break}}null==(t=a)||t.focus()};return i.createElement("div",{className:(0,l.Z)("tabs-container",c)},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":o},g)},f.map((e=>{let{value:t,label:a,attributes:o}=e;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:_===t?0:-1,"aria-selected":_===t,key:t,ref:e=>S.push(e),onKeyDown:O,onFocus:I,onClick:I},o,{className:(0,l.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":_===t})}),a??t)}))),a?(0,i.cloneElement)(N.filter((e=>e.props.value===_))[0],{className:"margin-top--md"}):i.createElement("div",{className:"margin-top--md"},N.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==_})))))}function u(e){const t=(0,o.Z)();return i.createElement(d,(0,n.Z)({key:String(t)},e))}},88234:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var n=a(83117),i=(a(67294),a(3905)),l=a(65488),o=a(85162);const r={sidebar_position:14,title:"Super QBE"},p=void 0,s={unversionedId:"query/super_qbe",id:"query/super_qbe",title:"Super QBE",description:"Super QBE is a very powerful feature that uses DTO Language to generate parameter types for complex queries and automatically implement query logic.",source:"@site/docs/query/super_qbe.mdx",sourceDirName:"query",slug:"/query/super_qbe",permalink:"/jimmer-doc/docs/query/super_qbe",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/super_qbe.mdx",tags:[],version:"current",lastUpdatedAt:1709106190,formattedLastUpdatedAt:"Feb 28, 2024",sidebarPosition:14,frontMatter:{sidebar_position:14,title:"Super QBE"},sidebar:"tutorialSidebar",previous:{title:"Querying Association Tables",permalink:"/jimmer-doc/docs/query/associations"},next:{title:"Modification",permalink:"/jimmer-doc/docs/mutation/"}},c={},m=[{value:"Create File",id:"create-file",level:2},{value:"Define Specification Type",id:"define-specification-type",level:2},{value:"Compiled Code",id:"compiled-code",level:3},{value:"Usage",id:"usage",level:3},{value:"Attribute Mapping",id:"attribute-mapping",level:2},{value:"Map Attributes",id:"map-attributes",level:3},{value:"Nullability",id:"nullability",level:3},{value:"Usage",id:"usage-1",level:3},{value:"QBE Functions",id:"qbe-functions",level:2},{value:"Introduction to QBE Functions",id:"introduction-to-qbe-functions",level:3},{value:"like Function Options",id:"like-function-options",level:3},{value:"All QBE Functions",id:"all-qbe-functions",level:3},{value:"Comprehensive Example",id:"comprehensive-example",level:3},{value:"Associated Objects",id:"associated-objects",level:2},{value:"Logical OR",id:"logical-or",level:2}],d={toc:m};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Super QBE is a very powerful feature that uses ",(0,i.kt)("a",{parentName:"p",href:"../object/view/dto-language"},"DTO Language")," to generate parameter types for complex queries and automatically implement query logic."),(0,i.kt)("h2",{id:"create-file"},"Create File"),(0,i.kt)("p",null,"In any project that can access entity types, create the ",(0,i.kt)("inlineCode",{parentName:"p"},"src/main/dto")," directory, and create the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.dto")," file in this directory."),(0,i.kt)("p",null,"For Java projects, if the current project is not the project that defines the entity type, you need to add the ",(0,i.kt)("inlineCode",{parentName:"p"},"@EnableDtoGeneration")," annotation to any class in the current project."),(0,i.kt)("p",null,"Add the following code to the head of the file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"export com.yourcompany.yourproject.model.Book\n    -> package com.yourcompany.yourproject.dto\n")),(0,i.kt)("p",null,"The above steps, as well as how to compile DTO files, are discussed in detail in ",(0,i.kt)("a",{parentName:"p",href:"../object/view/dto-language#2-create-file"},"DTO Language #2. Create File"),", and will not be repeated here."),(0,i.kt)("h2",{id:"define-specification-type"},"Define Specification Type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted... \n\nspecification BookSpecification {\n\n}\n")),(0,i.kt)("h3",{id:"compiled-code"},"Compiled Code"),(0,i.kt)("p",null,"After compilation, Java/Kotlin code like this will be generated:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookSpecification.java"',title:'"BookSpecification.java"'},"package com.yourcompany.yourproject.dto;\n\nimport org.babyfish.jimmer.sql.ast.query.specification.JSpecification;\nimport org.babyfish.jimmer.sql.ast.query.specification.SpecificationArgs;\n...other imports omitted...\n\npublic class BookSpecification implements JSpecification<Book, BookTable> {\n\n    @Override\n    public void applyTo(SpecificationArgs<Book, BookTable> args) {}\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookSpecification.kt"',title:'"BookSpecification.kt"'},"package com.yourcompany.yourproject.dto;\n\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecification\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecificationArgs\n...other imports omitted...\n\ndata class BookSpecification(\n    // Now data class has no fields, will cause compile error  \n) : KSpecification<Book> {\n\n    override fun applyTo(args: KSpecificationArgs<Book>) {}\n}\n")))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"applyTo")," is a method specific to the compiled specification code. It dynamically adds where conditions to Jimmer queries according to the information of the current object. "),(0,i.kt)("p",{parentName:"admonition"},"This method does not require user invocation ",(0,i.kt)("em",{parentName:"p"},"(invoked by internal Jimmer behaviors)"),", and users do not need to care about its internal code implementation. Just knowing what this method does is enough here.")),(0,i.kt)("p",null,"In subsequent discussions, we will gradually add properties to ",(0,i.kt)("inlineCode",{parentName:"p"},"BookSpecification")," in the DTO file."),(0,i.kt)("p",null,"Accordingly, for the automatically generated ",(0,i.kt)("inlineCode",{parentName:"p"},"BookSpecification")," class, on the one hand, properties will be added synchronously, on the other hand, the code in the ",(0,i.kt)("inlineCode",{parentName:"p"},"applyTo")," method will also grow."),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use in queries"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public List<Book> find(\n    // highlight-next-line  \n    JSpecification<?, BookTable> specification \u2776\n) {\n    \n    BookTable table = Tables.BOOK_TABLE;\n    \n    return sqlClient\n        .createQuery(table)\n        // highlight-next-line\n        .where(specification) \u2777\n        .select(table)\n        .execute();\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun find(\n    // highlight-next-line\n    specification: KSpecification<Book> \u2776\n): List<Book> =\n    sqlClient.createQuery(Book::class) {\n        // highlight-next-line\n        where(specification) \u2777\n        select(table)\n    }.execute()\n")))),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 The query parameter type in Java is ",(0,i.kt)("inlineCode",{parentName:"p"},"JSpecification<?, BookTable>"),", and in Kotlin it is ",(0,i.kt)("inlineCode",{parentName:"p"},"KSpecification<Book>"),"."),(0,i.kt)("p",{parentName:"li"},"There are subtle differences between them, but both inherit from the ",(0,i.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.Specification<Book>")," type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 No matter how simple or complex the ",(0,i.kt)("inlineCode",{parentName:"p"},"specification")," format is, it can be used with just a simple ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," statement.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use in Spring Data Repository"),(0,i.kt)("p",{parentName:"li"},"Jimmer integrates Spring Data, so Spring Data Repository can be defined, please refer to ",(0,i.kt)("a",{parentName:"p",href:"../spring/repository"},"Spring Data Style")," to learn more."),(0,i.kt)("p",{parentName:"li"},"Jimmer's Spring Data Repository has two query styles, abstract methods and default methods. The code using specification in default methods is the same as above, so let's look at an example of using specification in abstract query methods:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public interface BookRepository : JRepository<Book, Long> {\n\n    public List<Book> find(\n        // highlight-next-line\n        Specification<Book> specification\n    )\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"interface BookRepository : KRepository<Book, Long> {\n\n    fun find(\n        // highlight-next-line\n        specification: Specification<Book>\n    ): List<Book>\n}\n")))),(0,i.kt)("p",{parentName:"li"},"When declaring the specification parameter in the abstract method of the Spring Data Repository, there is no need to distinguish between ",(0,i.kt)("inlineCode",{parentName:"p"},"JSpecification")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"KSpecification"),".\nJust use the ",(0,i.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.Specification")," type."))),(0,i.kt)("h2",{id:"attribute-mapping"},"Attribute Mapping"),(0,i.kt)("h3",{id:"map-attributes"},"Map Attributes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...\n\nspecification BookSpecification {\n    #highlight-next-line\n    name\n} \n")),(0,i.kt)("p",null,"This maps entity properties to DTOs. The generated code is:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookSpecification.java"',title:'"BookSpecification.java"'},"public class BookSpecification implements JSpecification<Book, BookTable> {\n\n    @Nullable\n    // highlight-next-line\n    private String name;\n\n    ...getters and setters omitted...\n\n    @Override\n    public void applyTo(SpecificationArgs<Book, BookTable> args) {\n        ...omitted...\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookSpecification.kt"',title:'"BookSpecification.kt"'},"package com.yourcompany.yourproject.dto;\n\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecification\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecificationArgs\n...other imports omitted...\n\ndata class BookSpecification(\n    // highlight-next-line\n    val name: String? = null\n) : KSpecification<Book> {\n\n    override fun applyTo(args: KSpecificationArgs<Book>) {\n        ...omitted... \n    }\n}\n")))),(0,i.kt)("h3",{id:"nullability"},"Nullability"),(0,i.kt)("p",null,"We find that in the generated code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," field can be null, which is where the specialty of specification lies."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Specifications are used as query parameters. To support dynamic queries, all properties are nullable by default unless explicitly specified as non-nullable using ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," ",(0,i.kt)("em",{parentName:"p"},"(see ",(0,i.kt)("a",{parentName:"em",href:"../object/view/dto-language#7-nullability"},"DTO Language #7. Nullability"),")"),".")),(0,i.kt)("h3",{id:"usage-1"},"Usage"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," field of BookSpecifiation be null"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"BookSpecification specification = new BookSpecification();\nList<Book> books = bookRepository.find(specification);\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"val specification = BookSpecification()\nval books = bookRepository.find(specification) \n")))),(0,i.kt)("p",{parentName:"li"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"specification.name")," is null, the generated SQL does not contain any ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," conditions."),(0,i.kt)("p",{parentName:"li"},"The generated SQL is:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_ \nwhere tb_1_.NAME = ?\n")),(0,i.kt)("admonition",{parentName:"li",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Such queries that do not specify relevant specification properties will inevitably lead to queries without any conditions. "),(0,i.kt)("p",{parentName:"admonition"},"This example is only demonstrated once in this article."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Make the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," field of BookSpecifiation non-null"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookSpecification specification = new BookSpecification();\n// highlight-next-line\nspecification.setName("GraphQL in Action");\nList<Book> books = bookRepository.find(specification);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val specification = BookSpecification(\n    // highlight-next-line\n    name = "GraphQL in Action"\n)\nval books = bookRepository.find(specification)\n')))),(0,i.kt)("p",{parentName:"li"},"The generated SQL is:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_\n/* highlight-next-line */    \nwhere tb_1_.NAME = ? /* GraphQL in Action */\n")))),(0,i.kt)("h2",{id:"qbe-functions"},"QBE Functions"),(0,i.kt)("h3",{id:"introduction-to-qbe-functions"},"Introduction to QBE Functions"),(0,i.kt)("p",null,"In the code above, when ",(0,i.kt)("inlineCode",{parentName:"p"},"specification.name")," is specified, the generated ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," condition is equality. "),(0,i.kt)("p",null,"Equality is not necessarily what we need. QBE functions can be applied to mapped properties to change the operator. Take ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," as an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...\n\nspecification BookSpecification {\n    #highlight-next-line\n    like(name)\n}\n")),(0,i.kt)("p",null,"The like function does not affect the properties of the generated ",(0,i.kt)("inlineCode",{parentName:"p"},"BookSpecification")," class, but affects its ",(0,i.kt)("inlineCode",{parentName:"p"},"applyTo")," method, whose internal implementation is the ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," condition addition logic that users do not need to care about."),(0,i.kt)("p",null,"Execute:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookSpecification specification = new BookSpecification();\n// highlight-next-line  \nspecification.setName("GraphQL");\nList<Book> books = bookRepository.find(specification);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val specification = BookSpecification(\n    // highlight-next-line\n    name = "GraphQL" \n)\nval books = bookRepository.find(specification)\n')))),(0,i.kt)("p",null,"The generated SQL is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_\n/* highlight-next-line */  \nwhere tb_1_.NAME like ? /* %GraphQL% */\n")),(0,i.kt)("h3",{id:"like-function-options"},"like Function Options"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"like")," is a special one among all QBE functions, supporting 3 options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"i: Case insensitive ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"^: Exact match at the beginning ",(0,i.kt)("em",{parentName:"p"},"(Jimmer does not automatically add ",(0,i.kt)("inlineCode",{parentName:"em"},"%")," before the parameter value)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"$: Exact match at the end ",(0,i.kt)("em",{parentName:"p"},"(Jimmer does not automatically add ",(0,i.kt)("inlineCode",{parentName:"em"},"%")," after the parameter value)")))),(0,i.kt)("p",null,"If options are needed, ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," can be added after ",(0,i.kt)("inlineCode",{parentName:"p"},"like"),", followed by the required options. Such as: ",(0,i.kt)("inlineCode",{parentName:"p"},"like/i"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"like/^"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"like/$"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"like/i^"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"like/i$"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"like/i^$"),". "),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Although ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," are optional, their order is fixed.")),(0,i.kt)("p",null,"Let's try case-insensitive ",(0,i.kt)("inlineCode",{parentName:"p"},"like")," by modifying the DTO code as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...   \n\nspecification BookSpecification {\n    #highlight-next-line\n    like/i(name)\n}\n")),(0,i.kt)("p",null,"Execute the code above again, the following SQL is executed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Databases that do not support ",(0,i.kt)("inlineCode",{parentName:"p"},"ilike"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID \nfrom BOOK tb_1_\n/* highlight-next-line */\nwhere lower(tb_1_.NAME) like ? /* %graphql% */\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Databases that support ",(0,i.kt)("inlineCode",{parentName:"p"},"ilike"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_ \n/* highlight-next-line */  \nwhere tb_1_.NAME ilike ? /* %graphql% */\n")))),(0,i.kt)("h3",{id:"all-qbe-functions"},"All QBE Functions"),(0,i.kt)("p",null,"In fact, in addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"like"),", speciation supports a large number of QBE functions covering common SQL judgments, as shown in the table below:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"QBE Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Original Entity Attribute Type ",(0,i.kt)("em",{parentName:"th"},"(or Requirement)")),(0,i.kt)("th",{parentName:"tr",align:null},"Generated DTO Class Attribute Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Remarks"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"eq"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Equal, equivalent to not using any QBE function")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ne"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Not equal")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"gt"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Greater than")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ge"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Greater than or equal to")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"lt"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Less than")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"le"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Original type"),(0,i.kt)("td",{parentName:"tr",align:null},"Less than or equal to")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"like"),(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"Fuzzy match")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"notLike"),(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"Fuzzy mismatch")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"null"),(0,i.kt)("td",{parentName:"tr",align:null},"Any property"),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"is null judgment if DTO property is true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"notNull"),(0,i.kt)("td",{parentName:"tr",align:null},"Any property"),(0,i.kt)("td",{parentName:"tr",align:null},"boolean"),(0,i.kt)("td",{parentName:"tr",align:null},"is not null judgment if DTO property is true")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"valueIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","Original type",">"),(0,i.kt)("td",{parentName:"tr",align:null},"in(...)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"valueNotIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Any non-associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","Original type",">"),(0,i.kt)("td",{parentName:"tr",align:null},"not in(...)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdEq"),(0,i.kt)("td",{parentName:"tr",align:null},"Any associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Type of associated entity's id property"),(0,i.kt)("td",{parentName:"tr",align:null},"Associated id = ?. Note that it is equivalent to ",(0,i.kt)("inlineCode",{parentName:"td"},"id")," ",(0,i.kt)("em",{parentName:"td"},"(inherent DTO language function)"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdNe"),(0,i.kt)("td",{parentName:"tr",align:null},"Any associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"Type of associated entity's id property"),(0,i.kt)("td",{parentName:"tr",align:null},"Associated id ","<",">"," ?")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Any associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","Type of associated entity's id property",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Associated id in(...)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdNotIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Any associative property"),(0,i.kt)("td",{parentName:"tr",align:null},"List","<","Type of associated entity's id property",">"),(0,i.kt)("td",{parentName:"tr",align:null},"Associated id not in(...)")))),(0,i.kt)("h3",{id:"comprehensive-example"},"Comprehensive Example"),(0,i.kt)("p",null,"Modify the DTO code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...\n\nspecification BookSpecification {\n    like/i(name)\n    ge(price) \n    le(price)\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ge(price)")," will specify the default alias ",(0,i.kt)("inlineCode",{parentName:"p"},"minPrice"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"le(price)")," will specify the default alias ",(0,i.kt)("inlineCode",{parentName:"p"},"maxPrice"),", so the above code can also be written as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...  \n\nspecification BookSpecification {\n    like/i(name)\n    ge(price) as minPrice\n    le(price) as maxPrice\n} \n")),(0,i.kt)("p",null,"As you can see, some QBE functions have built-in default alias functionality. "),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Assuming the original property name is ",(0,i.kt)("inlineCode",{parentName:"strong"},"Prop")),", the default alias behaviors of all QBE functions are as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"QBE Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Default alias"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"eq ",(0,i.kt)("em",{parentName:"td"},"(or no QBE function specified)")),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"prop"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ne"),(0,i.kt)("td",{parentName:"tr",align:null},"Not supported, no alias specified will cause compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"gt"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"minPropExclusive"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ge"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"minProp"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"lt"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxPropExclusive"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"le"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"maxProp"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"like"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"prop"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"notLike"),(0,i.kt)("td",{parentName:"tr",align:null},"Not supported, no alias specified will cause compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"valueIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Not supported, no alias specified will cause compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"valueNotIn"),(0,i.kt)("td",{parentName:"tr",align:null},"Not supported, no alias specified will cause compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdEq or id"),(0,i.kt)("td",{parentName:"tr",align:null},"If the association is a reference ",(0,i.kt)("em",{parentName:"td"},"(non-collection)"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"propId"),"; otherwise, compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdNe"),(0,i.kt)("td",{parentName:"tr",align:null},"If the association is a reference ",(0,i.kt)("em",{parentName:"td"},"(non-collection)"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"excludedPropId"),"; otherwise, compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdIn"),(0,i.kt)("td",{parentName:"tr",align:null},"If the association is a reference ",(0,i.kt)("em",{parentName:"td"},"(non-collection)"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"propIds"),"; otherwise, compile error")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"associatedIdNotNull"),(0,i.kt)("td",{parentName:"tr",align:null},"If the association is a reference ",(0,i.kt)("em",{parentName:"td"},"(non-collection)"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"excludedPropIds"),"; otherwise, compile error")))),(0,i.kt)("p",null,"The compiled code is:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookSpecification.java"',title:'"BookSpecification.java"'},"public class BookSpecification implements JSpecification<Book, BookTable> {\n\n    @Nullable\n    private String name;\n\n    @Nullable  \n    private BigDecimal minPrice;\n\n    @Nullable\n    private BigDecimal maxPrice;\n\n    ...getters and setters omitted...\n\n    @Override\n    public void applyTo(SpecificationArgs<Book, BookTable> args) {\n        ...omitted...\n    }\n}\n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookSpecification.kt"',title:'"BookSpecification.kt"'},"package com.yourcompany.yourproject.dto;\n\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecification\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecificationArgs  \n...other imports omitted...  \n\ndata class BookSpecification(\n    val name: String? = null,\n    val minPrice: BigDecimal? = null,\n    val maxPrice: BigDecimal? = null\n) : KSpecification<Book> {\n\n    override fun applyTo(args: KSpecificationArgs<Book>) {\n        ...omitted...\n    }\n}\n")))),(0,i.kt)("p",null,"Execute:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookSpecification specification = new BookSpecification();\nspecification.setName("GraphQL");\nspecification.setMinPrice(new BigDecimal(40));  \nspecification.setMaxPrice(new BigDecimal(40));\nList<Book> books = bookRepository.find(specification);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val specification = BookSpecification(\n    name = "GraphQL",\n    minPrice = BigDecimal(40),\n    maxPrice = BigDecimal(60)  \n)\nval books = bookRepository.find(specification)\n')))),(0,i.kt)("p",null,"The generated SQL is: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_  \nwhere\n        lower(tb_1_.NAME) like ? /* %graphql% */  \n    and \n        tb_1_.PRICE >= ? /* 40 */\n    and\n        tb_1_.PRICE <= ? /* 60 */\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n")),(0,i.kt)("h2",{id:"associated-objects"},"Associated Objects"),(0,i.kt)("p",null,"In previous examples, all filtering rules are for fields of the current table. Now let's filter on associated objects. Modify the DTO file as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...  \n\nspecification BookSpecification {\n    like/i(name)\n    ge(price)\n    le(price)\n    #highlight-next-line\n    flat(store) { \u2776\n        like/i(name) as storeName\n    }\n    #highlight-next-line\n    flat(authors) { \u2777\n        like/i(firstName) as authorName \n    }\n}\n")),(0,i.kt)("p",null,"We find that the code above uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function. The ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function is discussed in detail in ",(0,i.kt)("a",{parentName:"p",href:"../object/view/dto-language#104-flat-function"},"DTO Language #10.4-flat function"),", and will not be repeated here.  "),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"specification")," serves as a parameter for complex queries, it is very likely to be HTTP GET parameters. Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"flat")," function to eliminate associations and generate flattened DTO objects is more beneficial for developing HTTP GET APIs based on Spring MVC.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.store")," is a reference association")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.authors")," is a collection association"))),(0,i.kt)("p",null,"The compiled code is:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookSpecification.java"',title:'"BookSpecification.java"'},"public class BookSpecification implements JSpecification<Book, BookTable> {\n\n    @Nullable\n    private String name;\n\n    @Nullable\n    private BigDecimal minPrice;\n\n    @Nullable\n    private BigDecimal maxPrice;\n\n    @Nullable\n    private String storeName;\n\n    @Nullable\n    private String authorName;\n\n    ...getters and setters omitted... \n\n    @Override\n    public void applyTo(SpecificationArgs<Book, BookTable> args) {\n        ...omitted...\n    }\n} \n"))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookSpecification.kt"',title:'"BookSpecification.kt"'},"package com.yourcompany.yourproject.dto;\n\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecification\nimport org.babyfish.jimmer.sql.kt.ast.query.specification.KSpecificationArgs\n...other imports omitted...\n\ndata class BookSpecification(\n    val name: String? = null,\n    val minPrice: BigDecimal? = null,\n    val maxPrice: BigDecimal? = null, \n    val storeName: String? = null,\n    val authorName: String? = null\n) : KSpecification<Book> {\n\n    override fun applyTo(args: KSpecificationArgs<Book>) {\n        ...omitted...\n    }\n} \n")))),(0,i.kt)("p",null,"Execute:"),(0,i.kt)(l.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'BookSpecification specification = new BookSpecification();\nspecification.setStoreName("MANNING");\nspecification.setAuthorName("a");\nList<Book> books = bookRepository.find(specification);\n'))),(0,i.kt)(o.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'val specification = BookSpecification(\n    storeName = "MANNING",\n    authorName = "a"  \n)\nval books = bookRepository.find(specification)\n')))),(0,i.kt)("p",null,"The generated SQL is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK tb_1_ \n/* highlight-next-line */  \ninner join BOOK_STORE tb_2_ /* \u2776 */\n    on tb_1_.STORE_ID = tb_2_.ID\nwhere\n        tb_2_.NAME ilike ? /* %manning% */  \n    and\n        /* highlight-next-line */\n        exists( /* \u2777 */\n            select \n                1\n            from AUTHOR tb_3_\n            inner join BOOK_AUTHOR_MAPPING tb_4_ \n                on tb_3_.ID = tb_4_.AUTHOR_ID\n            where\n                    tb_1_.ID = tb_4_.BOOK_ID\n                and  \n                    tb_3_.FIRST_NAME ilike ? /* %a% */\n                        \n        )\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2776 ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.store")," is a reference association that does not break ",(0,i.kt)("a",{parentName:"p",href:"./dynamic-join/table-ex"},"pagination safety"),"."),(0,i.kt)("p",{parentName:"li"},"So only ",(0,i.kt)("a",{parentName:"p",href:"./dynamic-join/"},"dynamic JOIN")," is needed to apply the filtering condition represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"storeName")," property of the DTO object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2777 ",(0,i.kt)("inlineCode",{parentName:"p"},"Book.authors")," is a collection association that breaks ",(0,i.kt)("a",{parentName:"p",href:"./dynamic-join/table-ex"},"pagination safety"),"."),(0,i.kt)("p",{parentName:"li"},"So ",(0,i.kt)("a",{parentName:"p",href:"./sub-query"},"subqueries")," must be used instead of ",(0,i.kt)("a",{parentName:"p",href:"./dynamic-join/"},"dynamic JOIN")," to apply the filtering condition represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"authorName")," property of the DTO object."))),(0,i.kt)("h2",{id:"logical-or"},"Logical OR"),(0,i.kt)("p",null,"In previous examples, Jimmer generates multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," conditions according to each property of the DTO object, and the relationship between these conditions is logical AND. But can logical OR be supported?"),(0,i.kt)("p",null,"In addition, the entity type ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," has the ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," property in addition to the ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," property. Mapping only ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"authorName")," in the previous example does not seem reasonable. Is there a better way?"),(0,i.kt)("p",null,"The above two issues are the same issue. To solve this problem, Super QBE supports logical OR, also known as multi-property mapping."),(0,i.kt)("p",null,"Modify the DTO code as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"...export statement omitted...\n\nspecification BookSpecification {\n    like/i(name)\n    ge(price)\n    le(price)\n    flat(store) {\n        like/i(name) as storeName\n    }\n    flat(authors) {\n        // highlight-next-line\n        like/i(firstName, lastName) as authorName\n    }\n}\n")),(0,i.kt)("p",null,"Here, the DTO property ",(0,i.kt)("inlineCode",{parentName:"p"},"authorName")," maps two properties, ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName"),". This is called multi-property mapping."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Multi-property mapping can only be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"specification")," and cannot be used in other types described in ",(0,i.kt)("a",{parentName:"p",href:"../object/view/dto-language"},"DTO Language"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The types of multiple properties mapped by QBE functions must be completely consistent ",(0,i.kt)("em",{parentName:"p"},"(but nullability is allowed to differ)"),". For example, both ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," here are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The DTO property of multi-property mapping must be aliased via ",(0,i.kt)("inlineCode",{parentName:"p"},"as"),", otherwise compilation errors will occur. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Not all QBE functions support multi-property mapping. QBE functions that support multi-property mapping are:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"eq"),(0,i.kt)("li",{parentName:"ul"},"ne "),(0,i.kt)("li",{parentName:"ul"},"null"),(0,i.kt)("li",{parentName:"ul"},"notNull"),(0,i.kt)("li",{parentName:"ul"},"valueIn"),(0,i.kt)("li",{parentName:"ul"},"associatedIdEq"),(0,i.kt)("li",{parentName:"ul"},"associatedIdIn")),(0,i.kt)("p",{parentName:"li"},"Allowing all QBE functions to support multi-property mapping blindly would lead to ambiguous understanding. So there is this restriction."))),(0,i.kt)("p",null,"Repeating the query in the previous example generates the following SQL:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID \nfrom BOOK tb_1_\ninner join BOOK_STORE tb_2_\n    on tb_1_.STORE_ID = tb_2_.ID\nwhere\n        tb_2_.NAME ilike ? /* %manning% */\n    and\n        exists(\n            select\n                1 \n            from AUTHOR tb_3_\n            inner join BOOK_AUTHOR_MAPPING tb_4_\n                on tb_3_.ID = tb_4_.AUTHOR_ID\n            where  \n                    tb_1_.ID = tb_4_.BOOK_ID\n                and\n                    (\n                        tb_3_.FIRST_NAME ilike ? /* %a% */  \n                    /* highlight-next-line */  \n                        or\n                        tb_3_.LAST_NAME ilike ? /* %a% */\n                    )\n        )\n")),(0,i.kt)("p",null,"It is not difficult to see that multi-property mapping is logical OR."))}u.isMDXComponent=!0}}]);