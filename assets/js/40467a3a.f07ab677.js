"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[260],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),m=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=m(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=m(t),u=o,g=c["".concat(s,".").concat(u)]||c[u]||d[u]||r;return t?a.createElement(g,i(i({ref:n},p),{},{components:t})):a.createElement(g,i({ref:n},p))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var m=2;m<r;m++)i[m]=t[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>i});var a=t(67294),o=t(34334);const r="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r,i),hidden:t},n)}},65488:(e,n,t)=>{t.d(n,{Z:()=>u});var a=t(83117),o=t(67294),r=t(34334),i=t(72389),l=t(67392),s=t(7094),m=t(12466);const p="tabList__CuJ",d="tabItem_LNqP";function c(e){var n;const{lazy:t,block:i,defaultValue:c,values:u,groupId:g,className:k}=e,b=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),y=u??b.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),h=(0,l.l)(y,((e,n)=>e.value===n.value));if(h.length>0)throw new Error(`Docusaurus error: Duplicate values "${h.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===c?c:c??(null==(n=b.find((e=>e.props.default)))?void 0:n.props.value)??b[0].props.value;if(null!==N&&!y.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${y.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:_}=(0,s.U)(),[v,T]=(0,o.useState)(N),B=[],{blockElementScrollPositionUntilNextRender:I}=(0,m.o5)();if(null!=g){const e=f[g];null!=e&&e!==v&&y.some((n=>n.value===e))&&T(e)}const x=e=>{const n=e.currentTarget,t=B.indexOf(n),a=y[t].value;a!==v&&(I(n),T(a),null!=g&&_(g,String(a)))},R=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{const n=B.indexOf(e.currentTarget)+1;t=B[n]??B[0];break}case"ArrowLeft":{const n=B.indexOf(e.currentTarget)-1;t=B[n]??B[B.length-1];break}}null==(n=t)||n.focus()};return o.createElement("div",{className:(0,r.Z)("tabs-container",p)},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":i},k)},y.map((e=>{let{value:n,label:t,attributes:i}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===n?0:-1,"aria-selected":v===n,key:n,ref:e=>B.push(e),onKeyDown:R,onFocus:x,onClick:x},i,{className:(0,r.Z)("tabs__item",d,null==i?void 0:i.className,{"tabs__item--active":v===n})}),t??n)}))),t?(0,o.cloneElement)(b.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):o.createElement("div",{className:"margin-top--md"},b.map(((e,n)=>(0,o.cloneElement)(e,{key:n,hidden:e.props.value!==v})))))}function u(e){const n=(0,i.Z)();return o.createElement(c,(0,a.Z)({key:String(n)},e))}},15120:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>m,toc:()=>d});var a=t(83117),o=(t(67294),t(3905)),r=t(65488),i=t(85162);const l={sidebar_position:2,title:"Simple Queries"},s=void 0,m={unversionedId:"spring/repository/abstract",id:"spring/repository/abstract",title:"Simple Queries",description:"Just like other Spring Data implementations, users can define abstract methods in the Repository interface. As long as the names, parameters and return values of these methods follow conventions, Jimmer implements them automatically. For example:",source:"@site/docs/spring/repository/abstract.mdx",sourceDirName:"spring/repository",slug:"/spring/repository/abstract",permalink:"/jimmer-doc/docs/spring/repository/abstract",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/spring/repository/abstract.mdx",tags:[],version:"current",lastUpdatedAt:1731427770,formattedLastUpdatedAt:"Nov 12, 2024",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Simple Queries"},sidebar:"tutorialSidebar",previous:{title:"Define Repository",permalink:"/jimmer-doc/docs/spring/repository/concept"},next:{title:"Complex Queries",permalink:"/jimmer-doc/docs/spring/repository/default"}},p={},d=[{value:"Dynamic WHERE",id:"dynamic-where",level:2},{value:"Dynamic JOIN",id:"dynamic-join",level:2},{value:"Dynamic ORDER BY",id:"dynamic-order-by",level:2},{value:"Paged Queries",id:"paged-queries",level:2},{value:"Object Fetchers",id:"object-fetchers",level:2}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Just like other Spring Data implementations, users can define abstract methods in the Repository interface. As long as the names, parameters and return values of these methods follow conventions, Jimmer implements them automatically. For example:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    List<Book> findByNameOrderByEditionDesc(\n        @Nullable String name\n    );\n\n    List<Book> findByPriceBetweenOrderByName(\n        @Nullable BigDecimal minPrice,\n        @Nullable BigDecimal maxPrice\n    );\n\n    long countByName(String name);\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    fun findByNameOrderByEditionDesc(\n        name: String?\n    ): List<Book>\n\n    fun findByPriceBetweenOrderByName(\n        minPrice: BigDecimal?,\n        maxPrice: BigDecimal?\n    ): List<Book>\n\n    fun countByName(String name): Long\n}\n")))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"There are various conventions for method names, but basic usage is similar to Spring Data JPA. "),(0,o.kt)("p",{parentName:"admonition"},"So please refer to ",(0,o.kt)("a",{parentName:"p",href:"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords"},"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords"),", this article will not repeat it.")),(0,o.kt)("h2",{id:"dynamic-where"},"Dynamic WHERE"),(0,o.kt)("p",null,"You may have noticed that in the above examples, many parameters can be null."),(0,o.kt)("p",null,"In Jimmer, the automatically implemented abstract methods are inherently dynamic queries, that is, any query parameter can be null."),(0,o.kt)("p",null,"Let's look at another more representative example, where the abstract method is defined as:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    List<Book> findByNameLikeIgnoreCaseAndPriceBetween(\n        @Nullable String name,\n        @Nullable BigDecimal minPrice,\n        @Nullable BigDecimal maxPrice\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book  \n\nimport org.babyfish.jimmer.spring.repository.KRepository\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    fun findByNameLikeIgnoreCaseAndPriceBetween(\n        name: String? = null,\n        minPrice: BigDecimal? = null,\n        maxPrice: BigDecimal? = null\n    ): List<Book>\n}\n")))),(0,o.kt)("p",null,"Each parameter of this method can be null, look at the 6 possible invocations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Not specify any parameters"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        null,\n        null,\n        null\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween()\n")))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify name"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        "G",\n        null,\n        null\n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(name = "G")\n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere lower(tb_1_.NAME) like ? /* %g% */ \n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify minPrice"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        null,\n        new BigDecimal(40), \n        null\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        minPrice = BigDecimal(40)\n    )\n")))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_  \nwhere tb_1_.PRICE >= ? /* 40 */\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify maxPrice"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        null,\n        null,\n        new BigDecimal(60)\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        maxPrice = BigDecimal(60)\n    )\n")))),"The generated SQL is (formatted for readability):",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_  \nwhere tb_1_.PRICE <= ? /* 60 */\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify both minPrice and maxPrice"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        null,\n        new BigDecimal(40),\n        new BigDecimal(60)\n    );\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        null,\n        BigDecimal(40), \n        BigDecimal(60)\n    )\n")))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_  \nwhere \n    (tb_1_.PRICE between ? /* 40 */ and ? /* 60 */)\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify all parameters"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        "G",\n        new BigDecimal(40),\n        new BigDecimal(60) \n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByNameLikeIgnoreCaseAndPriceBetween(\n        "G",\n        BigDecimal(40),\n        BigDecimal(60)\n    )\n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_  \nwhere\n    lower(tb_1_.NAME) like ? /* %g% */\nand \n    (tb_1_.PRICE between ? /* 40 */ and ? /* 60 */)\n")))),(0,o.kt)("h2",{id:"dynamic-join"},"Dynamic JOIN"),(0,o.kt)("p",null,"Users can not only apply filters to properties of the currently queried object, but also to properties of associated objects. For example:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    // name -> `Book.name`\n    // storeName -> `Book.store.name`\n    List<Book> findByNameStartsWithAndStoreName(\n        @Nullable String name,\n        @Nullable String storeName\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    // name -> `Book.name`\n    // storeName -> `Book.store.name`\n    fun findByNameStartsWithAndStoreName(\n        name: String? = null,\n        storeName: String? = null\n    ): List<Book> \n}\n")))),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"findByNameStartWithAndStoreName")," actually refers to ",(0,o.kt)("inlineCode",{parentName:"p"},"store.name"),"."),(0,o.kt)("p",null,"It means a join is performed through ",(0,o.kt)("inlineCode",{parentName:"p"},"Book.store")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore")," first, then a condition is applied on ",(0,o.kt)("inlineCode",{parentName:"p"},"BookStore.name"),"."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"JOIN will only be generated in the SQL if the ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," parameter is specified")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The association that can be used by the convention method must be a non-collection association (one-to-one, many-to-one)")))),(0,o.kt)("p",null,"Let's see how to use it:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," parameter, no JOIN"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByNameStartsWithAndStoreName("G", null);\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByNameStartsWithAndStoreName("G")\n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_ \nwhere tb_1_.NAME like ? /* G% */\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Specify ",(0,o.kt)("inlineCode",{parentName:"p"},"storeName")," parameter, JOIN generated"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByNameStartsWithAndStoreName(null, "MANNING");\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByNameStartsWithAndStoreName(null, "MANNING") \n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\n/* highlight-next-line */  \ninner join BOOK_STORE as tb_2_\n    on tb_1_.STORE_ID = tb_2_.ID\nwhere tb_2_.NAME = ? /* MANNING */\n")))),(0,o.kt)("h2",{id:"dynamic-order-by"},"Dynamic ORDER BY"),(0,o.kt)("p",null,"As long as the abstract method has a parameter of type ",(0,o.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Sort"),", dynamic ordering can be achieved. For example:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.data.domain.Sort;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    List<Book> findByNameLikeIgnoreCase(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough,  no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable. \n        @Nullable String name,\n\n        // highlight-next-line  \n        @Nullable Sort sort\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book  \n\nimport org.babyfish.jimmer.spring.repository.KRepository\nimport org.springframework.data.domain.Sort\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    fun findByNameLikeIgnoreCase(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough, no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable.\n        name: String? = null,\n\n        // highlight-next-line\n        sort: Sort? = null\n    ): List<Book>\n}\n")))),(0,o.kt)("p",null,"To facilitate the top-level code to accept sorting strings from the frontend, Jimmer provides the utility class ",(0,o.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.spring.model.SortUtils")," to convert the sorting string passed from the client to ",(0,o.kt)("inlineCode",{parentName:"p"},"org.springframework.data.domain.Sort"),"."),(0,o.kt)("p",null,"It can be used like:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Sort sort = SortUtils.toSort(\n    "store.name asc", "name asc", "edition desc"\n);\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sort = SortUtils.toSort(\n    "store.name asc", "name asc", "edition desc"  \n)\n')))),"or",(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Sort sort = SortUtils.toSort( \n    "store.name asc, name asc, edition desc"\n);\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val sort = SortUtils.toSort(\n    "store.name asc, name asc, edition desc"\n);\n')))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"ORDER BY without JOIN"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByName(\n        null,\n        SortUtils.toSort("name, edition desc") \n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByName(\n        null,\n        SortUtils.toSort("name, edition desc")\n    )\n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\n/* highlight-next-line */\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc \n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"ORDER BY requiring JOIN"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'List<Book> books = bookRepository\n    .findByName(\n        null,\n        SortUtils.toSort("store.name, name, edition desc")\n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = bookRepository\n    .findByName(\n        null,\n        SortUtils.toSort("store.name, name, edition desc") \n    )\n')))),(0,o.kt)("p",{parentName:"li"},"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"select tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\n/* highlight-next-line */\nleft join BOOK_STORE as tb_2_\n    on tb_1_.STORE_ID = tb_2_.ID\n/* highlight-next-line */  \norder by\n    tb_2_.NAME asc,\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n")))),(0,o.kt)("h2",{id:"paged-queries"},"Paged Queries"),(0,o.kt)("p",null,"To perform paged queries, the method needs:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A parameter of type ",(0,o.kt)("inlineCode",{parentName:"li"},"org.springframework.data.domain.Pageable")," "),(0,o.kt)("li",{parentName:"ul"},"Return ",(0,o.kt)("inlineCode",{parentName:"li"},"org.springframework.data.domain.Page<Current Entity>"))),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\nimport org.jetbrains.annotations.Nullable;\n/* highlight-start */\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Page;\n/* highlight-end */\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    // highlight-next-line\n    Page<Book> findByName(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough, no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable.\n        @Nullable String name,\n\n        // highlight-next-line\n        Pageable pageable\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\n/* highlight-start */  \nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.domain.Page\n/* highlight-end */\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    fun findByName(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough, no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable.\n        name: String? = null,\n\n        // highlight-next-line\n        pageable: Pageable\n\n    // highlight-next-line\n    ): Page<Book>\n}\n")))),(0,o.kt)("p",null,"It can be used like:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Page<Book> page = bookRepository\n    .findByName(\n        null,\n        PageRequest.of(\n            1, // zero based, 1 means second page\n            5, \n            SortUtils.toSort("name, edition desc")\n        )\n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val page = bookRepository\n    .findByName(\n        null,\n        PageRequest.of(\n            1, // zero based, 1 means second page\n            5,\n            SortUtils.toSort("name, edition desc")\n        )\n    )\n')))),(0,o.kt)("p",null,"The returned Page object is like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    // highlight-next-line\n    "content":[\n        {\n            "id":10,\n            "name":"GraphQL in Action",\n            "edition":1,\n            "price":80,\n            "store":{\n                "id":2\n            }\n        },\n        {\n            "id":3,\n            "name":"Learning GraphQL",\n            "edition":3,\n            "price":51,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":2,\n            "name":"Learning GraphQL",\n            "edition":2,\n            "price":55,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":1,\n            "name":"Learning GraphQL",\n            "edition":1,\n            "price":45,\n            "store":{\n                "id":1\n            }\n        },\n        {\n            "id":9,\n            "name":"Programming TypeScript",\n            "edition":3,\n            "price":48,\n            "store":{\n                "id":1\n            }\n        }\n    ],\n    "pageable":{\n        "sort":{\n            "unsorted":false,\n            "sorted":true,\n            "empty":false\n        },\n        "pageNumber":1,\n        "pageSize":5,\n        "offset":5,\n        "paged":true,\n        "unpaged":false\n    },\n    // highlight-start\n    "totalPages":3, \n    "totalElements":12,\n    "last":false,\n    "numberOfElements":5,\n    // highlight-end\n    "first":false,\n    "sort":{\n        "unsorted":false,\n        "sorted":true,\n        "empty":false\n    },\n    "number":1,\n    "size":5,\n    "empty":false\n}\n')),(0,o.kt)("p",null,"The generated SQL is (formatted for readability):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query total rows before paging */\nselect count(tb_1_.ID) from BOOK as tb_1_\n\n/* Step 2: Query data within one page */ \nselect tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc\n/* MySQL paging */\n/* highlight-next-line */  \nlimit ?, /* 5 (offset) */ ? /* 5 (limit) */ \n")),(0,o.kt)("h2",{id:"object-fetchers"},"Object Fetchers"),(0,o.kt)("p",null,"Object fetchers are one of Jimmer's signature features, allowing querying of arbitrary complex data structures instead of just simple entity objects."),(0,o.kt)("p",null,"Adding a parameter of type ",(0,o.kt)("inlineCode",{parentName:"p"},"org.babyfish.jimmer.sql.fetcher.Fetcher<Current Entity>")," makes the abstract method capable of this."),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="BookRepository.java"',title:'"BookRepository.java"'},"package com.example.repository;\n\nimport com.example.model.Book;\n\nimport org.babyfish.jimmer.spring.repository.JRepository;\n// highlight-next-line\nimport org.babyfish.jimmer.sql.fetcher.Fetcher;\nimport org.jetbrains.annotations.Nullable;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Page;\n\npublic interface BookRepository extends JRepository<Book, Long> {\n\n    Page<Book> findByName(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough, no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable.\n        @Nullable String name,\n\n        Pageable pageable,\n\n        // highlight-next-line\n        @Nullable Fetcher<Book> fetcher\n    );\n}\n"))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="BookRepository.kt"',title:'"BookRepository.kt"'},"package com.example.repository\n\nimport com.example.model.Book\n\nimport org.babyfish.jimmer.spring.repository.KRepository\n// highlight-next-line \nimport org.babyfish.jimmer.sql.fetcher.Fetcher\nimport org.springframework.data.domain.Pageable\nimport org.springframework.data.domain.Page\n\ninterface BookRepository : KRepository<Book, Long> {\n\n    fun findByName(\n\n        // This parameter is not used in subsequent examples, always null.\n        // Reason:\n        // If a query does not need any parameters, the method from base \n        // interface is enough, no need to define this method. The value \n        // of this parameter in this example is solely to make the current \n        // custom abstract method look reasonable.\n        name: String? = null,\n\n        pageable: Pageable,\n\n        // highlight-next-line\n        fetcher: Fetcher<Book>? = null\n    ): Page<Book>\n}\n")))),(0,o.kt)("p",null,"If no Fetcher is passed or a shape of simple objects is passed, the result will be necessarily similar to previous examples, no need to repeat."),(0,o.kt)("p",null,"So let's just demonstrate querying a complex data structure:"),(0,o.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,o.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Page<Book> page = bookRepository\n    .findByName(\n        null,\n        PageRequest.of(\n            1, // zero based, 1 means second page\n            5,\n            SortUtils.toSort("name, edition desc") \n        ),\n        // highlight-next-line\n        Fetchers.BOOK_FETCHER\n            .allScalarFields()\n            // highlight-next-line\n            .store(\n                Fetchers.BOOK_FETCHER\n                    .name() // associated object only queries id (implicit+mandatory) and name\n            )\n            // highlight-next-line \n            .authors(\n                Fetchers.AUTHOR_FETCHER\n                    // associated object only queries id (implicit+mandatory), firstName and lastName\n                    .firstName().lastName() \n            )\n    );\n'))),(0,o.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},'val page = bookRepository\n    .findByName(\n        null,\n        PageRequest.of(\n            1, // zero based, 1 means second page \n            5,\n            SortUtils.toSort("name, edition desc")\n        ),\n        // highlight-next-line\n        newFetcher(Book::class).by {\n            allScalarFields()\n            // highlight-next-line\n            store {\n                // associated object only queries id \n                // (implicit+mandatory) and name\n                name()\n            }\n            // highlight-next-line\n            authors {\n                // associated object only queries \n                // id (implicit+mandatory), firstName and lastName\n                firstName()\n                lastName()\n            }\n        }\n    )\n')))),(0,o.kt)("p",null,"The returned Page object is: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "content":[\n        {\n            "id":10,\n            "name":"GraphQL in Action",\n            "edition":1,\n            "price":80,\n            // highlight-next-line\n            "store":{\n                "id":2,\n                "name":"MANNING"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":5,\n                    "firstName":"Samer",\n                    "lastName":"Buna"\n                }\n            ]\n        },\n        {\n            "id":3,\n            "name":"Learning GraphQL",\n            "edition":3,\n            "price":51,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,  \n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":2,\n            "name":"Learning GraphQL",\n            "edition":2,\n            "price":55,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,\n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":1,\n            "name":"Learning GraphQL",\n            "edition":1,\n            "price":45,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":2,\n                    "firstName":"Alex",\n                    "lastName":"Banks"\n                },\n                {\n                    "id":1,\n                    "firstName":"Eve",\n                    "lastName":"Procello"\n                }\n            ]\n        },\n        {\n            "id":9, \n            "name":"Programming TypeScript",\n            "edition":3,\n            "price":48,\n            // highlight-next-line\n            "store":{\n                "id":1,\n                "name":"O\'REILLY"\n            },\n            // highlight-next-line\n            "authors":[\n                {\n                    "id":4,\n                    "firstName":"Boris",\n                    "lastName":"Cherny"\n                }\n            ]\n        }\n    ],\n    "pageable":{\n        "sort":{\n            "unsorted":false,\n            "sorted":true,\n            "empty":false\n        },\n        "pageNumber":1, \n        "pageSize":5,\n        "offset":5,\n        "paged":true,\n        "unpaged":false\n    },\n    "totalPages":3,\n    "totalElements":12,\n    "last":false,\n    "sort":{\n        "unsorted":false,\n        "sorted":true,\n        "empty":false\n    },\n    "numberOfElements":5, \n    "number":1,\n    "first":false,\n    "size":5,\n    "empty":false\n}\n')),(0,o.kt)("p",null,"The generated SQL is (formatted for readability):  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sql"},"/* Step 1: Query total rows before paging */ \nselect count(tb_1_.ID) from BOOK as tb_1_\n\n/* Step 2: Query aggregate root objects within one page */\nselect tb_1_.ID, tb_1_.NAME, tb_1_.EDITION, tb_1_.PRICE, tb_1_.STORE_ID\nfrom BOOK as tb_1_\norder by\n    tb_1_.NAME asc,\n    tb_1_.EDITION desc \n/* MySQL paging */\nlimit ?, /* 5 (offset) */ ? /* 5 (limit) */\n\n/*  \n * Step 3: For the 5 paged data (not 12 rows before paging),\n * query the associated objects of property `Book.store`\n * \n * Note:\n * In current case, the foreign key `STORE_ID` will be queried, so finding parent\n * objects directly via foreign key. Although there are 5 rows of data, \n * the foreign keys only have two distinct values, so only two SQL params.\n */\nselect tb_1_.ID, tb_1_.NAME  \nfrom BOOK_STORE as tb_1_\nwhere tb_1_.ID in (  \n    ?, ? \n    /* actual param list: 2, 1 */  \n)\n\n/* \n * Step 4: For the 5 paged data (not 12 rows before paging), \n * query the associated objects of property `Book.authors`\n */\nselect tb_2_.BOOK_ID, tb_1_.ID, tb_1_.FIRST_NAME, tb_1_.LAST_NAME\nfrom AUTHOR as tb_1_\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (\n    ?, ?, ?, ?, ? \n    /* actual param list: 10, 3, 2, 1, 9 */\n)\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Whether it is simple queries discussed in this article, or complex queries to be discussed in ",(0,o.kt)("a",{parentName:"p",href:"./default"},"next article"),", as long as the query returns entity objects or their collections instead of simple column tuples, it is highly recommended to add a ",(0,o.kt)("inlineCode",{parentName:"p"},"Fetcher")," parameter to make all object queries as powerful in data structure shaping as ",(0,o.kt)("inlineCode",{parentName:"p"},"GraphQL"),"."),(0,o.kt)("p",{parentName:"admonition"},"This brings great convenience to higher level business code.  ")))}u.isMDXComponent=!0}}]);