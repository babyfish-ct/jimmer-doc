"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[4557],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=p(n),u=l,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,i=new Array(o);i[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,i[1]=r;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(67294),l=n(34334);const o="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(o,i),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(83117),l=n(67294),o=n(34334),i=n(72389),r=n(67392),s=n(7094),p=n(12466);const c="tabList__CuJ",m="tabItem_LNqP";function d(e){var t;const{lazy:n,block:i,defaultValue:d,values:u,groupId:h,className:k}=e,b=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),N=u??b.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),_=(0,r.l)(N,((e,t)=>e.value===t.value));if(_.length>0)throw new Error(`Docusaurus error: Duplicate values "${_.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===d?d:d??(null==(t=b.find((e=>e.props.default)))?void 0:t.props.value)??b[0].props.value;if(null!==g&&!N.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${N.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:y}=(0,s.U)(),[T,O]=(0,l.useState)(g),v=[],{blockElementScrollPositionUntilNextRender:I}=(0,p.o5)();if(null!=h){const e=f[h];null!=e&&e!==T&&N.some((t=>t.value===e))&&O(e)}const C=e=>{const t=e.currentTarget,n=v.indexOf(t),a=N[n].value;a!==T&&(I(t),O(a),null!=h&&y(h,String(a)))},E=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=v.indexOf(e.currentTarget)+1;n=v[t]??v[0];break}case"ArrowLeft":{const t=v.indexOf(e.currentTarget)-1;n=v[t]??v[v.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,o.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":i},k)},N.map((e=>{let{value:t,label:n,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>v.push(e),onKeyDown:E,onFocus:C,onClick:C},i,{className:(0,o.Z)("tabs__item",m,null==i?void 0:i.className,{"tabs__item--active":T===t})}),n??t)}))),n?(0,l.cloneElement)(b.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},b.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function u(e){const t=(0,i.Z)();return l.createElement(d,(0,a.Z)({key:String(t)},e))}},32102:(e,t,n)=>{n.d(t,{s:()=>k});var a=n(83117),l=n(67294),o=n(42293),i=n(50657),r=n(6514),s=n(54776),p=n(10155),c=n(15861),m=n(93946),d=n(9137),u=n(61274),h=n(50594);const k=(0,l.memo)((e=>{let{open:t,fullScreen:n=!1,title:a,maxWidth:s="md",onClose:k,children:N}=e;const[_,g]=(0,l.useState)(n),f=(0,l.useCallback)((()=>{g((e=>!e))}),[]);return l.createElement(i.Z,{open:t,onClose:k,fullScreen:_,TransitionComponent:b,maxWidth:s},l.createElement(o.Z,{sx:{position:"relative"}},l.createElement(p.Z,null,l.createElement(c.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},a),l.createElement(m.Z,{onClick:f,style:{color:"white"}},_?l.createElement(u.Z,null):l.createElement(d.Z,null)),l.createElement(m.Z,{"aria-label":"close",onClick:k,style:{color:"white"}},l.createElement(h.Z,null)))),l.createElement(r.Z,null,N))})),b=l.forwardRef((function(e,t){return l.createElement(s.Z,(0,a.Z)({direction:"up",ref:t},e))}))},39511:(e,t,n)=>{n.d(t,{b:()=>i});var a=n(67294),l=n(83321),o=n(32102);const i=(0,a.memo)((e=>{let{buttonText:t,fullScreen:n=!1,title:i=t,variant:r="outlined",maxWidth:s,useOriginalText:p=!0,children:c}=e;const[m,d]=(0,a.useState)(!1),u=(0,a.useCallback)((e=>{d(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),h=(0,a.useCallback)((()=>{d(!1)}),[]),k=p?{textTransform:"none"}:{};return a.createElement(a.Fragment,null,a.createElement(l.Z,{"data-is-view-more-button":"true",onClick:u,variant:r,size:"small",style:k},t),a.createElement(o.s,{open:m,onClose:h,title:i,maxWidth:s,fullScreen:n},c))}))},49525:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>m,default:()=>b,frontMatter:()=>c,metadata:()=>d,toc:()=>h});var a=n(83117),l=(n(67294),n(3905)),o=n(65488),i=n(85162),r=n(39511);const s={toc:[]};function p(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Readers can first ignore the concept of ",(0,l.kt)("inlineCode",{parentName:"p"},"filters"),", it is just to keep this article highly rigorous, not the content to be discussed here. "),(0,l.kt)("p",null,"If you want to understand, it contains two parts:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#property-level-filters"},"The last section of this article: Property Filters")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter"},"Global Filters"))))}p.isMDXComponent=!0;const c={sidebar_position:3,title:"Associations"},m=void 0,d={unversionedId:"query/object-fetcher/association",id:"query/object-fetcher/association",title:"Associations",description:"In last doc we introduced scalar property fetching. In this doc we discuss association fetching.",source:"@site/docs/query/object-fetcher/association.mdx",sourceDirName:"query/object-fetcher",slug:"/query/object-fetcher/association",permalink:"/jimmer-doc/docs/query/object-fetcher/association",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/object-fetcher/association.mdx",tags:[],version:"current",lastUpdatedAt:1704100403,formattedLastUpdatedAt:"Jan 1, 2024",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Associations"},sidebar:"tutorialSidebar",previous:{title:"Ordinary Properties",permalink:"/jimmer-doc/docs/query/object-fetcher/props"},next:{title:"Recursive Query",permalink:"/jimmer-doc/docs/query/object-fetcher/recursive"}},u={},h=[{value:"Fetch associated objects with only id",id:"fetch-associated-objects-with-only-id",level:2},{value:"ManyToOne: Book.store",id:"manytoone-bookstore",level:3},{value:"ManyToMany: Book.authors",id:"manytomany-bookauthors",level:3},{value:"Fetch complex associated objects",id:"fetch-complex-associated-objects",level:2},{value:"ManyToOne: Book.store",id:"manytoone-bookstore-1",level:3},{value:"ManyToMany: Book.authors",id:"manytomany-bookauthors-1",level:3},{value:"Fetching all table fields",id:"fetching-all-table-fields",level:2},{value:"Special Configurations for Associations",id:"special-configurations-for-associations",level:2},{value:"BatchSize",id:"batchsize",level:3},{value:"Pagination at Association Level",id:"pagination-at-association-level",level:3},{value:"Property-level Filters",id:"property-level-filters",level:3}],k={toc:h};function b(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"In ",(0,l.kt)("a",{parentName:"p",href:"./props"},"last doc")," we introduced scalar property fetching. In this doc we discuss association fetching."),(0,l.kt)("p",null,"ORM has two types of association properties:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Reference association: Associated with a single object ",(0,l.kt)("em",{parentName:"p"},"(or null)"),", the property return type is an entity object,\nused to express one-to-one and many-to-one associations. "),(0,l.kt)("admonition",{parentName:"li",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"This article uses the many-to-one association property ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," as an example."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Collection association: Associated with multiple objects, the property return type is a list of entities,\nused to express one-to-many and many-to-many associations. "),(0,l.kt)("admonition",{parentName:"li",type:"info"},(0,l.kt)("p",{parentName:"admonition"},"This article uses the many-to-many association property ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," as an example.")))),(0,l.kt)("h2",{id:"fetch-associated-objects-with-only-id"},"Fetch associated objects with only id"),(0,l.kt)("p",null,"When fetching associated objects without any parameters, only the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property of the associated objects is returned. "),(0,l.kt)("h3",{id:"manytoone-bookstore"},"ManyToOne: Book.store"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER\n                .allScalarFields()\n                // highlight-next-line\n                .store()\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n.createQuery(Book::class) {\n    where(table.edition.eq(3))\n    select(\n        table.fetchBy {\n            allScalarFields()\n            // highlight-next-line\n            store()\n        }\n    )\n}\n.execute()\n")))),(0,l.kt)("p",null,"Here, ",(0,l.kt)("inlineCode",{parentName:"p"},"store()")," indicates fetching the associated object. We did not specify any parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"store()"),", which means only the id property of the associated object is fetched."),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK tb_1_\nwhere tb_1_.EDITION = ?\n")),(0,l.kt)("p",null,"Since the many-to-one association ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," is based on a real foreign key, the foreign key ",(0,l.kt)("inlineCode",{parentName:"p"},"STORE_ID")," of the current table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK")," is the id of the parent object. "),(0,l.kt)("p",null,"Because ",(0,l.kt)("inlineCode",{parentName:"p"},"store()")," only fetches the id property of the associated object, no additional SQL query is required. The parent object with only the id property can be directly constructed from the foreign key in the current data."),(0,l.kt)("p",null,"The returned value is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        // highlight-next-line\n        "store": {\n            "id": 1\n        }\n    },\n    ...other objects omitted...\n]\n')),(0,l.kt)("h3",{id:"manytomany-bookauthors"},"ManyToMany: Book.authors"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER.\n                .allScalarFields()\n                // highlight-next-line\n                .authors()\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                authors()\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"Here, ",(0,l.kt)("inlineCode",{parentName:"p"},"authors()")," indicates fetching the associated objects. We did not specify any parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"authors()"),", which means only the id property of the associated objects is fetched."),(0,l.kt)("p",null,"Two SQLs are generated:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects themselves"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE\nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Based on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," association, query for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Author")," associated objects with only id for all root objects queried in the previous step"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.BOOK_ID, /* batch-map key */\n    tb_1_.AUTHOR_ID /* batch-map value */\nfrom BOOK_AUTHOR_MAPPING as tb_1_ \n    where tb_1_.BOOK_ID in (?, ?, ?, ?)\n")))),(0,l.kt)("p",null,"This example demonstrates:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The query only needs the id of the associated objects, and no filters are used (filters will be explained later)."),(0,l.kt)("p",{parentName:"li"},"Jimmer optimizes this case by only querying the ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table instead of the ",(0,l.kt)("inlineCode",{parentName:"p"},"AUTHOR")," table, because the middle table already contains the id of the associated objects.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where tb_1_.BOOK_ID in (?, ?, ?, ?)")," is a batch query, because the first query returns 4 root objects."),(0,l.kt)("p",{parentName:"li"},"Jimmer uses batch queries to solve the N+1 problem, similar to DataLoader in GraphQL."),(0,l.kt)("p",{parentName:"li"},"When a batch becomes too large, jimmer-sql will split it into smaller batches. This will be explained in the ",(0,l.kt)("a",{parentName:"p",href:"#batchsize"},"BatchSize")," section.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Jimmer queries the associated objects via separate SQL instead of using LEFT JOIN in the main query SQL to fetch associated objects."),(0,l.kt)("p",{parentName:"li"},"This is designed to avoid duplicate results when joining collection associations, which can be devastating for paged queries on aggregate roots."))),(0,l.kt)("p",null,"The printed result is (formatted for readability, original output is compact):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n        // highlight-next-line\n        "authors":[\n            {"id":1},\n            {"id":2}\n        ]\n    },\n    ...other objects omitted...\n]\n')),(0,l.kt)("h2",{id:"fetch-complex-associated-objects"},"Fetch complex associated objects"),(0,l.kt)("p",null,"When fetching associated objects, parameters can be specified to get associated objects with more information."),(0,l.kt)("h3",{id:"manytoone-bookstore-1"},"ManyToOne: Book.store"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER\n                .allScalarFields()\n                // highlight-next-line\n                .store(\n                    Fetchers.BOOK_STORE_FETCHER\n                        // highlight-next-line\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n.createQuery(Book::class) {\n    where(table.edition.eq(3))\n    select(\n        table.fetchBy {\n            allScalarFields()\n            // highlight-next-line\n            store {\n                // highlight-next-line\n                allScalarFields()\n            }\n        }\n    )\n}\n.execute()\n")))),(0,l.kt)("p",null,"Here, ",(0,l.kt)("inlineCode",{parentName:"p"},"store(...)")," indicates fetching the associated object. We specify parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"store(...)")," to fetch information other than id of the associated object."),(0,l.kt)("p",null,"Two SQLs are generated:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query for ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK tb_1_\nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Based on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.store")," association, query for relatively complete ",(0,l.kt)("inlineCode",{parentName:"p"},"BookStore")," associated objects for all root objects queried in the previous step"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.WEBSITE\nfrom BOOK_STORE tb_1_\nwhere tb_1_.ID in (?, ?)\n")))),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"where tb_1_.ID in (?, ?)")," is a batch query. The first query returns 4 root objects, but the foreign key values are deduplicated to only 2 values."),(0,l.kt)("p",null,"The returned value is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        // highlight-next-line\n        "store": {\n            "id": 1,\n            "name": "O\'REILLY",\n            "website": null\n        }\n    },\n    ...other objects omitted...  \n]\n')),(0,l.kt)("h3",{id:"manytomany-bookauthors-1"},"ManyToMany: Book.authors"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER.\n                .allScalarFields()\n                // highlight-next-line\n                .authors(\n                    Fetchers.AUTHOR_FETCHER\n                        // highlight-next-line\n                        .allScalarFields()\n                )\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                // highlight-next-line\n                authors {\n                    // highlight-next-line\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"Here, ",(0,l.kt)("inlineCode",{parentName:"p"},"authors(...)")," indicates fetching the associated objects. We specify parameters for ",(0,l.kt)("inlineCode",{parentName:"p"},"authors(...)")," to fetch information other than id of the associated objects."),(0,l.kt)("p",null,"Two SQLs are generated: "),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects themselves"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select \n    tb_1_.ID, \n    tb_1_.NAME, \n    tb_1_.EDITION, \n    tb_1_.PRICE\nfrom BOOK as tb_1_  \nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Based on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book.authors")," association, query for relatively complete ",(0,l.kt)("inlineCode",{parentName:"p"},"Author")," associated objects for all root objects queried in previous step"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    /* batch-map key */\n    tb_2_.BOOK_ID,\n\n    /* batch-map value */\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\n\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_\n    on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?, ?, ?)\n")))),(0,l.kt)("p",null,"This example shows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Information other than id is required for the associated objects, so both the ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table and the ",(0,l.kt)("inlineCode",{parentName:"p"},"AUTHOR")," table are queried, besides just the middle table.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where tb_2_.BOOK_ID in (?, ?, ?, ?)")," is a batch query, because the first query returns 4 root objects."),(0,l.kt)("p",{parentName:"li"},"Jimmer uses batch queries to solve the N+1 problem, similar to DataLoader in GraphQL.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Jimmer queries the associated objects via separate SQL instead of using LEFT JOIN in the main query SQL."),(0,l.kt)("p",{parentName:"li"},"This is designed to avoid duplicate results when joining collection associations, which can be devastating for paged queries on aggregate roots."))),(0,l.kt)("p",null,"The printed result is (formatted for readability):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n        // highlight-next-line\n        "authors":[\n            {\n                "id": 1,\n                "firstName": "Eve",\n                "lastName": "Procello",\n                "gender": "FEMALE"\n            },\n            {\n                "id": 2,\n                "firstName": "Alex",\n                "lastName": "Banks",\n                "gender": "MALE"\n            }\n        ]\n    },\n    ...other objects omitted...\n]\n')),(0,l.kt)("h2",{id:"fetching-all-table-fields"},"Fetching all table fields"),(0,l.kt)("p",null,"In some cases, all fields defined in the table are needed. ",(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," can be used for this."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," fetches all properties defined in the table, including all scalar properties (same as ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields"),"), one-to-one/many-to-one associations based on foreign keys. It does not include one-to-many, many-to-many associations, one-to-one/many-to-one associations based on middle tables, calculated properties or view properties. "),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},(0,l.kt)("inlineCode",{parentName:"p"},"allTableFields")," includes all one-to-one/many-to-one associations based on foreign keys, in addition to ",(0,l.kt)("inlineCode",{parentName:"p"},"allScalarFields"),". The fetched associated objects only have the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property.")),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER\n                // highlight-next-line\n                .allTableFields()\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookAllTableFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                // highlight-next-line\n                allTableFields()\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"The result is: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        // highlight-next-line\n        "store": {\n            "id": 1\n        }\n    }\n    ...other objects omitted\n]\n')),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"In some cases, ",(0,l.kt)("inlineCode",{parentName:"p"},"select(table.fetch(Fetchers.XXX_FETCHER.allTableFields()))")," is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"select(table)"),". The latter can be considered as shorthand for the former."),(0,l.kt)("p",{parentName:"admonition"},"The equivalence holds when associated objects are not affected by ",(0,l.kt)(r.b,{buttonText:"filters",mdxType:"ViewMore"},(0,l.kt)(p,{mdxType:"FilterRef"})),".")),(0,l.kt)("p",null,"The simple equivalent shorthand is:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    // highlight-next-line\n    .select(book)  \n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookAllScalarFields = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        // highlight-next-line\n        select(table)\n    }\n    .execute()\n\n")))),(0,l.kt)("h2",{id:"special-configurations-for-associations"},"Special Configurations for Associations"),(0,l.kt)("h3",{id:"batchsize"},"BatchSize"),(0,l.kt)("p",null,"For one-to-many/many-to-many associations, a large number of associated objects may impact application performance. The ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," configuration is provided for management."),(0,l.kt)("p",null,"The following example does not configure ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize"),":"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n                Fetchers.BOOK_FETCHER.allScalarFields()\n                // highlight-next-line\n                .authors(Fetchers.AUTHOR_FETCHER.allScalarFields())\n        )\n    )\n    .execute();\nSystem.out.println(toJson(list));\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allTableFields()\n                authors {\n                    // highlight-next-line\n                    allScalarFields()\n                }\n            }\n        )\n    }\n.execute()\n")))),(0,l.kt)("p",null,"The generated SQL is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"# 1. Query book table to get all BOOK_ID\nselect\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE\nfrom BOOK tb_1_\nwhere tb_1_.EDITION = ?\n\n# 2. Use BOOK_ID from previous step to join query author table\nselect\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?, ?, ?)\n")),(0,l.kt)("p",null,"In this example, no ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," is configured so the default will be used. All BOOK_ID will be directly used in the ",(0,l.kt)("inlineCode",{parentName:"p"},"in(...)")," list of the second query."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "id": 3,\n        "name": "Learning GraphQL",\n        "edition": 3,\n        "price": 51.00,\n        "authors": [\n            {\n                "id": 1,\n                "firstName": "Eve",\n                "lastName": "Procello",\n                "gender": "FEMALE"\n            },\n            {\n                "id": 2,\n                "firstName": "Alex",\n                "lastName": "Banks",\n                "gender": "MALE"\n            }\n        ]\n    },\n    ...omit other objects\n]\n\n')),(0,l.kt)("p",null,"In the example above, we see the query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID  \nwhere tb_2_.BOOK_ID in (?, ?, ?, ?)\n")),(0,l.kt)("p",null,"Here, the ",(0,l.kt)("inlineCode",{parentName:"p"},"in")," expression implements batch query to solve ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," problem."),(0,l.kt)("p",null,"If a batch is too large, it will be split into multiple batches based on ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," configuration, such as:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\nList<Book> list = sqlClient.createQuery(book)\n    .where(book.edition().eq(3))\n    .select(\n        book.fetch(\n                Fetchers.BOOK_FETCHER.allScalarFields()\n                // highlight-next-line\n                .authors(Fetchers.AUTHOR_FETCHER.allScalarFields(), it -> it.batch(2))\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // highlight-next-line\n                    batch(2)\n                }) {}\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{type:"danger"},(0,l.kt)("p",{parentName:"admonition"},"Here the ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," is set to 2. Such a small value would cause poor performance, it is only for demo purposes. Please do not use such small values in real projects.")),(0,l.kt)("p",null,"This would cause the ",(0,l.kt)("inlineCode",{parentName:"p"},"in(?, ?, ?, ?)")," to be split into two ",(0,l.kt)("inlineCode",{parentName:"p"},"in(?, ?)"),", and the SQL to fetch associated objects would be split into two."),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME, \n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?) \n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"})),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_2_.BOOK_ID,\n    tb_1_.ID,\n    tb_1_.FIRST_NAME,\n    tb_1_.LAST_NAME,\n    tb_1_.GENDER\nfrom AUTHOR tb_1_\ninner join BOOK_AUTHOR_MAPPING tb_2_ on tb_1_.ID = tb_2_.AUTHOR_ID\nwhere tb_2_.BOOK_ID in (?, ?)\n")),(0,l.kt)("p",null,"In real projects, in most cases ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," would not be configured like this at fetcher level. Instead, use the global configurations in ",(0,l.kt)("inlineCode",{parentName:"p"},"SqlClient"),": "),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultBatchSize()"),": Default ",(0,l.kt)("inlineCode",{parentName:"li"},"batchSize")," for one-to-one and many-to-one associations, default 128"),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"JSqlClient.getDefaultListBatchSize()"),": Default ",(0,l.kt)("inlineCode",{parentName:"li"},"batchSize")," for one-to-many and many-to-many associations, default 16")),(0,l.kt)("p",null,"When creating ",(0,l.kt)("inlineCode",{parentName:"p"},"SqlClient"),", the global configs can be changed:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Using spring boot"),(0,l.kt)("p",{parentName:"li"},"Add configuration into ",(0,l.kt)("inlineCode",{parentName:"p"},"application.yml")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"application.properties")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:'language-title="application.yml"'},"jimmer:\n    default-batch-size: 256\n    default-list-batch-size: 32\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Using low-level API"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"JSqlClient sqlClient = JSqlClient\n    .newBuilder()\n    .setDefaultBatchSize(256) \n    .setDefaultListBatchSize(32)\n    ....\n    build();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val sqlClient = newKSqlClient {\n    setDefaultBatchSize(256)\n    setDefaultListBatchSize(32)\n    ....\n    }\n")))))),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"No matter association-level ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," or global ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize"),", do not set above 1000 because Oracle database allows max 1000 values in ",(0,l.kt)("inlineCode",{parentName:"p"},"in(...)"),".")),(0,l.kt)("h3",{id:"pagination-at-association-level"},"Pagination at Association Level"),(0,l.kt)("p",null,"For collection associations, ",(0,l.kt)("inlineCode",{parentName:"p"},"limit(limit, offset)")," can be specified during fetching to do pagination at association level."),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Association-level pagination and batch loading cannot coexist. Association-level pagination necessarily causes ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," problem. Please use this feature cautiously!"),(0,l.kt)("p",{parentName:"admonition"},"If association-level pagination is used, ",(0,l.kt)("inlineCode",{parentName:"p"},"batchSize")," must be set to 1, otherwise exceptions would be thrown. This is designed to make it clear to developers and readers that the code has ",(0,l.kt)("inlineCode",{parentName:"p"},"N+1")," performance risk.")),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .select(\n        book.fetch(\n            Fetchers.BOOK_FETCHER\n            .allScalarFields()\n            .authors(\n                Fetchers.AUTHOR_FETCHER.allScalarFields(),\n                // highlight-next-line\n                it -> it.batch(1).limit(/*limit*/ 10, /*offset*/ 90)\n            )\n        )\n    )\n    .execute();\n"))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n            // highlight-next-line\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    batch(1)\n                    // highlight-next-line\n                    limit(limit = 90, offset = 10)\n                    }) {\n                    allScalarFields()\n                }\n            }\n        )\n    }\n    .execute()\n")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Since association pagination cannot solve ",(0,l.kt)("inlineCode",{parentName:"li"},"N+1")," problem, multiple SQLs are generated"),(0,l.kt)("li",{parentName:"ul"},"For simplicity let's assume ",(0,l.kt)("inlineCode",{parentName:"li"},"H2Dialect")," is used so different databases have the same paging SQL")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query current ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE\nfrom BOOK as tb_1_\nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 1st ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object "),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME, \n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_  \ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID\nwhere tb_1_.BOOK_ID = ?\n/* highlight-next-line */\nlimit ? offset ?  \n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 2nd ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 3rd ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object "),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Paginated query on ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," collection of the 4th ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," object"),(0,l.kt)("p",{parentName:"li"},"Same as above, omitted."))),(0,l.kt)("h3",{id:"property-level-filters"},"Property-level Filters"),(0,l.kt)("p",null,"When fetching associations, filters can be specified to filter associated objects."),(0,l.kt)("p",null,"Here for comparison, the query selects two columns, both are ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," type. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the first column uses filter"),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"Book.authors")," of the second column does not use filter")),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<Tuple2<Book, Book>> books = sqlClient\n    .createQuery(book)\n    .select(\n        // First column  \n        book.fetch(\n            Fetchers.BOOK_FETCHER\n            .allScalarFields()\n            .authors(\n                Fetchers.AUTHOR_FETCHER.allScalarFields(),\n\n                // Use filter\n                // highlight-next-line\n                it -> it.filter(args -> {\n                    args.where(args.getTable().firstName().ilike("a"));\n                })\n            )\n        ),\n\n        // Second column\n        book.fetch(\n            Fetchers.BOOK_FETCHER\n                .allScalarFields()\n                .authors(\n                    Fetchers.AUTHOR_FETCHER.allScalarFields()\n                // No filter used\n                )\n        )\n    )\n    .execute();\n'))),(0,l.kt)(i.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val tuples: List<Tuple2<Book, Book>> = sqlClient\n    .createQuery(Book::class) {\n        where(table.edition.eq(3))\n        select(\n\n            // First column\n            table.fetchBy {\n                allScalarFields()\n                authors({\n                    // Use filter\n                    // highlight-next-line\n                    filter {\n                    where(table.firstName ilike "a")\n                    }\n                }) {\n                    allScalarFields()\n                }\n            },\n\n            // Second column\n            table.fetchBy {\n                allScalarFields()\n                authors { // No filter used  \n                    allScalarFields()\n                }\n            }\n        )\n    }\n.execute()\n')))),(0,l.kt)("p",null,"Three SQLs are generated:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Query the two ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects needed for the tuple"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n/* For tuple._1 */  \n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n\n/* For tuple._2 */\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION, \n    tb_1_.PRICE\n\nfrom BOOK as tb_1_ \nwhere tb_1_.EDITION = ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For the ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," association of the 4 ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 1, use filter"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    tb_1_.BOOK_ID,\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME,\n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_\ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID \nwhere\n    tb_1_.BOOK_ID in (?, ?, ?, ?)  \nand\n    /* Use filter here */\n    /* highlight-next-line */\n    lower(tb_3_.FIRST_NAME) like ?\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For the ",(0,l.kt)("inlineCode",{parentName:"p"},"authors")," association of the 4 ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," objects in column 2, no filter"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n\n    tb_1_.BOOK_ID,\n    tb_1_.AUTHOR_ID,\n    tb_3_.FIRST_NAME,\n    tb_3_.LAST_NAME,\n    tb_3_.GENDER\nfrom BOOK_AUTHOR_MAPPING as tb_1_\ninner join AUTHOR as tb_3_ on tb_1_.AUTHOR_ID = tb_3_.ID\nwhere\n    tb_1_.BOOK_ID in (?, ?, ?, ?)\n/* No filter here */ \n")))),(0,l.kt)("p",null,"The printed result is (formatted for readability):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'Tuple2{\n    _1={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n\n        // Filter used, incomplete collection\n        // highlight-next-line\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE" \n            }\n        ]\n    },\n    _2={\n        "id":3,\n        "name":"Learning GraphQL",\n        "edition":3,\n        "price":51.00,\n\n        // No filter, complete collection \n        // highlight-next-line\n        "authors":[\n            {\n                "id":2,\n                "firstName":"Alex",\n                "lastName":"Banks",\n                "gender":"MALE"\n            },{\n                "id":"fd6bb6cf-336d-416c-8005-1ae11a6694b5",\n                "firstName":"Eve",\n                "lastName":"Procello",\n                "gender":"MALE"\n            }\n        ]\n    }\n}\n')),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"Filters can not only filter associated objects, but also sort them. The principle is similar so not demonstrated here. ")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("ol",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"For associations satisfying both below conditions, applying filters would cause exceptions:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Many-to-one"),(0,l.kt)("li",{parentName:"ul"},"Not null"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"After field filters are used, ",(0,l.kt)("a",{parentName:"p",href:"../../cache/cache-type/association"},"association cache")," for that field will be ignored. "),(0,l.kt)("p",{parentName:"li"},"To use the association cache, global filters supporting ",(0,l.kt)("a",{parentName:"p",href:"../../cache/multiview-cache"},"multi-view cache")," can be used.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"A common mistake in real development (Java for example) is:"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},'filter(it -> args.getTable().firstName().ilike("a"))')),(0,l.kt)("p",{parentName:"li"},"This creates the condition expression but does not call ",(0,l.kt)("inlineCode",{parentName:"p"},"args.where"),". Filter code not calling either ",(0,l.kt)("inlineCode",{parentName:"p"},"args.where")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"args.orderBy")," is meaningless."),(0,l.kt)("p",{parentName:"li"},"The correct code is:"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},'filter(it -> args.where(args.getTable().firstName().ilike("a")))'))))))}b.isMDXComponent=!0}}]);