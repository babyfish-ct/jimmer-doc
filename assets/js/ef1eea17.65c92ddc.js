"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[3003],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),m=p(n),u=l,b=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(b,o(o({ref:t},c),{},{components:n})):a.createElement(b,o({ref:t},c))}));function u(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=m;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),l=n(34334);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(i,o),hidden:n},t)}},65488:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(83117),l=n(67294),i=n(34334),o=n(72389),r=n(67392),s=n(7094),p=n(12466);const c="tabList__CuJ",d="tabItem_LNqP";function m(e){var t;const{lazy:n,block:o,defaultValue:m,values:u,groupId:b,className:k}=e,h=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),N=u??h.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),g=(0,r.l)(N,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const f=null===m?m:m??(null==(t=h.find((e=>e.props.default)))?void 0:t.props.value)??h[0].props.value;if(null!==f&&!N.some((e=>e.value===f)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${f}" but none of its children has the corresponding value. Available values are: ${N.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:T}=(0,s.U)(),[v,I]=(0,l.useState)(f),w=[],{blockElementScrollPositionUntilNextRender:_}=(0,p.o5)();if(null!=b){const e=y[b];null!=e&&e!==v&&N.some((t=>t.value===e))&&I(e)}const x=e=>{const t=e.currentTarget,n=w.indexOf(t),a=N[n].value;a!==v&&(_(t),I(a),null!=b&&T(b,String(a)))},O=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{const t=w.indexOf(e.currentTarget)+1;n=w[t]??w[0];break}case"ArrowLeft":{const t=w.indexOf(e.currentTarget)-1;n=w[t]??w[w.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,i.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},k)},N.map((e=>{let{value:t,label:n,attributes:o}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:v===t?0:-1,"aria-selected":v===t,key:t,ref:e=>w.push(e),onKeyDown:O,onFocus:x,onClick:x},o,{className:(0,i.Z)("tabs__item",d,null==o?void 0:o.className,{"tabs__item--active":v===t})}),n??t)}))),n?(0,l.cloneElement)(h.filter((e=>e.props.value===v))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},h.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==v})))))}function u(e){const t=(0,o.Z)();return l.createElement(m,(0,a.Z)({key:String(t)},e))}},32102:(e,t,n)=>{n.d(t,{s:()=>k});var a=n(83117),l=n(67294),i=n(42293),o=n(50657),r=n(6514),s=n(54776),p=n(10155),c=n(15861),d=n(93946),m=n(9137),u=n(61274),b=n(50594);const k=(0,l.memo)((e=>{let{open:t,fullScreen:n=!1,title:a,maxWidth:s="md",onClose:k,children:N}=e;const[g,f]=(0,l.useState)(n),y=(0,l.useCallback)((()=>{f((e=>!e))}),[]);return l.createElement(o.Z,{open:t,onClose:k,fullScreen:g,TransitionComponent:h,maxWidth:s},l.createElement(i.Z,{sx:{position:"relative"}},l.createElement(p.Z,null,l.createElement(c.Z,{sx:{ml:2,flex:1},variant:"h6",component:"div"},a),l.createElement(d.Z,{onClick:y,style:{color:"white"}},g?l.createElement(u.Z,null):l.createElement(m.Z,null)),l.createElement(d.Z,{"aria-label":"close",onClick:k,style:{color:"white"}},l.createElement(b.Z,null)))),l.createElement(r.Z,null,N))})),h=l.forwardRef((function(e,t){return l.createElement(s.Z,(0,a.Z)({direction:"up",ref:t},e))}))},39511:(e,t,n)=>{n.d(t,{b:()=>o});var a=n(67294),l=n(83321),i=n(32102);const o=(0,a.memo)((e=>{let{buttonText:t,fullScreen:n=!1,title:o=t,variant:r="outlined",large:s=!1,maxWidth:p,useOriginalText:c=!0,children:d}=e;const[m,u]=(0,a.useState)(!1),b=(0,a.useCallback)((e=>{u(!0),e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}),[]),k=(0,a.useCallback)((()=>{u(!1)}),[]),h=c?{textTransform:"none"}:{};return a.createElement(a.Fragment,null,a.createElement(l.Z,{"data-is-view-more-button":"true",onClick:b,variant:r,size:s?"large":"small",style:h},t),a.createElement(i.s,{open:m,onClose:k,title:o,maxWidth:p,fullScreen:n},d))}))},17222:(e,t,n)=>{n.d(t,{ZP:()=>o});var a=n(83117),l=(n(67294),n(3905));const i={toc:[{value:"Scene-1",id:"scene-1",level:2},{value:"Scene-2",id:"scene-2",level:2}]};function o(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Currently, other technologies that operate on SQL, whether ORM or non-ORM, have a blank area: they only consider dynamic ",(0,l.kt)("inlineCode",{parentName:"p"},"where"),", and do not consider ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic join"),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Dynamic JOIN")," is defined as: If some dynamic query conditions are for tables other than the current table. This means"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"When the condition is met: First join to other tables through association properties, then add dynamic where conditions to the joined table")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"When the condition is not met: Cannot join other tables through association properties"))),(0,l.kt)("h2",{id:"scene-1"},"Scene-1"),(0,l.kt)("p",null,"Let's first look at the first scene, taking MyBatis oriented to native SQL as an example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define MyBatis Mapper interface"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"@Mapper\npublic interface BookMapper {\n\n    List<Book> findBooks(\n        @Nullable String name,\n        @Nullable String storeName, \n        @Nullable String storeWebsite\n    );\n}\n")),(0,l.kt)("p",{parentName:"li"},"Here, all query parameters may be null, which is clearly a dynamic query."),(0,l.kt)("p",{parentName:"li"},"The last two query parameters: ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite"),", their filtering conditions are not applied on the current table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK"),", but on the parent table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_STORE"),".\nThat is, when any of these two parameters is non-null, a JOIN to the ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_STORE")," table will be generated. This table join dynamically determined by the parameter value is referred to as ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic JOIN")," in this article.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Define MyBatis SQL mapping XML"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="somepackage.BookMapper">\n    <select id="findBooks" resultType="somepackage.Book">\n        select * from BOOK as book\n        \x3c!-- highlight-next-line --\x3e\n        <if test="storeName != null or storeWebsite != null"> \u2776\n            inner join BOOK_STORE as store\n                on book.STORE_ID = store.ID\n        </if>\n        <where>\n            <if test="name != null">\n                and book.NAME = #{name}\n            </if>\n            <if test="storeName != null"> \u2777\n                and store.NAME = #{storeName}\n            </if>\n            <if test="storeWebsite != null">\n                and store.WEBSITE = #{storeWebsite} \u2778\n            </if>\n        </where>\n    </select>\n</mapper>\n')),(0,l.kt)("p",{parentName:"li"},"Here, \u2776 is the dynamic JOIN. However, for developers, \u2777 and \u2778 are the purpose, and \u2776 is the work that has to be done to support \u2777 and \u2778. Its judgment condition is a burden."),(0,l.kt)("p",{parentName:"li"},"You may have noticed that \u2776 uses ",(0,l.kt)("inlineCode",{parentName:"p"},"or"),". This is easy to understand."),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"However, this is only the simplest dynamic connection between two tables. For deeper multi-table join operations, the complexity of dynamic table joins will increase dramatically!")))),(0,l.kt)("h2",{id:"scene-2"},"Scene-2"),(0,l.kt)("p",null,"Let's take a look at the second scene. With the previous example as the basis, this example is decoupled from any business."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-xml"},'<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="somepackage.AMapper">\n  <select id="findAObjects" resultType="somepackage.A">\n    select distinct A.id\n    from A\n    \x3c!-- highlight-start --\x3e  \n    <if test="bId != null or cId != null or dId != null or eId != null">\n      inner join B on A.ID = B.A_ID \n    </if>\n    <if test="cId != null or dId != null or eId != null">\n      inner join C on B.ID = C.B_ID\n    </if>\n    <if test="dId != null or eId != null">\n      inner join D on C.ID = D.C_ID \n    </if>\n    <if test="eId != null">\n      inner join E on D.ID = E.D_ID\n    </if>\n    \x3c!-- highlight-end --\x3e\n    <where>\n      <if test="aId != null">\n        and A.ID = #{aId}  \n      </if>\n      <if test="bId != null">\n        and B.ID = #{bId}\n      </if>\n      <if test="cId != null">\n        and C.ID = #{cId}\n      </if>\n      <if test="dId != null">\n        and D.ID = #{dId}\n      </if>\n      <if test="eId != null">\n        and E.ID = #{eId}\n      </if>\n    </where>\n  </select>\n</mapper>\n')),(0,l.kt)("p",null,"The logic of this example is simple. The five tables A, B, C, D and E form a JOIN chain, and each table has a dynamic query condition. However, as you can see, the complexity of dynamic JOIN has become unacceptable."))}o.isMDXComponent=!0},42720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>c,default:()=>k,frontMatter:()=>p,metadata:()=>d,toc:()=>u});var a=n(83117),l=(n(67294),n(3905)),i=n(17222),o=n(65488),r=n(85162),s=n(39511);const p={sidebar_position:4,title:"Optimize Unnecessary Joins"},c=void 0,d={unversionedId:"query/dynamic-join/optimization",id:"query/dynamic-join/optimization",title:"Optimize Unnecessary Joins",description:"Usage",source:"@site/docs/query/dynamic-join/optimization.mdx",sourceDirName:"query/dynamic-join",slug:"/query/dynamic-join/optimization",permalink:"/jimmer-doc/docs/query/dynamic-join/optimization",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/query/dynamic-join/optimization.mdx",tags:[],version:"current",lastUpdatedAt:1704100403,formattedLastUpdatedAt:"Jan 1, 2024",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Optimize Unnecessary Joins"},sidebar:"tutorialSidebar",previous:{title:"Merge Conflict Joins",permalink:"/jimmer-doc/docs/query/dynamic-join/merge"},next:{title:"Pagination Safety",permalink:"/jimmer-doc/docs/query/dynamic-join/table-ex"}},m={},u=[{value:"Usage",id:"usage",level:2},{value:"Basic Concepts",id:"basic-concepts",level:3},{value:"Another Solution",id:"another-solution",level:3},{value:"Phantom Joins",id:"phantom-joins",level:2},{value:"Two ways to filter on associated ids",id:"two-ways-to-filter-on-associated-ids",level:3},{value:"Inapplicable Scenarios",id:"inapplicable-scenarios",level:3},{value:"Applicable scenarios",id:"applicable-scenarios",level:3},{value:"Half Joins",id:"half-joins",level:2},{value:"Two ways to filter on associated ids",id:"two-ways-to-filter-on-associated-ids-1",level:3},{value:"Inapplicable scenarios",id:"inapplicable-scenarios-1",level:3},{value:"Applicable scenarios",id:"applicable-scenarios-1",level:3}],b={toc:u};function k(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"usage"},"Usage"),(0,l.kt)("h3",{id:"basic-concepts"},"Basic Concepts"),(0,l.kt)("p",null,"In Jimmer SQL DSL, created join objects that are not used will be ignored. For example:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable table = Tables.BOOK_TABLE;\n\n// highlight-next-line\nSystem.out.println("Unsed join: " + table.store());\n\nList<Book> books = sqlClient\n    .createQuery(table) \n    .orderBy(table.name().asc(), table.edition().desc())\n    .select(table)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        \n        // highlight-next-line\n        println("Unsed join: ${table.store}")\n\n        orderBy(table.name.asc(), table.edition.desc())\n        select(table)\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"Although a JOIN object is created via ",(0,l.kt)("inlineCode",{parentName:"p"},"table.store"),", since it is not used by the SQL DSL of the current query, this JOIN object will be ignored."),(0,l.kt)("p",null,"Therefore, the final generated SQL will not contain any JOIN operations:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME, \n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_ \nwhere tb_1_.NAME = ?\n")),(0,l.kt)("h3",{id:"another-solution"},"Another Solution"),(0,l.kt)("p",null,"In ",(0,l.kt)(s.b,{buttonText:"Problems with current solutions",mdxType:"ViewMore"},(0,l.kt)(i.ZP,{mdxType:"DynamicJoinProblem"})),", we listed two scenarios. "),(0,l.kt)("p",null,"In the ",(0,l.kt)("a",{parentName:"p",href:"./merge"},"previous doc"),", we discussed solving these two scenarios by utilizing Jimmer SQL DSL's automatic merge of conflicting joins."),(0,l.kt)("p",null,"Here, we use another approach to solve the same problems."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Solve the problem in scenario 1:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"List<Book> findBooks(\n        @Nullable String name,\n        @Nullable String storeName,\n        @Nullable String storeWebsite\n) {\n    BookTable table = Tables.BOOK_TABLE;\n\n    // Create JOIN object unconditionally first,  \n    // will be auto ignored if not used later,\n    // so no useless JOIN\n    // highlight-next-line \n    BookStoreTable store = table.store();\n\n    return sqlClient\n        .createQuery(table)\n        .whereIf(\n            name != null,\n            () -> book.name().like(name)\n        )\n        .whereIf(\n            storeName != null, \n            () -> store.name().like(storeName)\n        )\n        .whereIf(\n            storeWebsite != null,\n            () -> store.website().like(storeWebsite)\n        )\n        .select(book)\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findBooks(\n    name: String? = null,\n    storeName: String? = null,\n    storeWebsite: String? = null\n): List<Book> {\n    return sqlClient\n        .createQuery(Book::class) {\n            \n            // Create JOIN object unconditionally first,\n            // will be auto ignored if not used later, \n            // so no useless JOIN\n            // highlight-next-line\n            val store = table.store\n            \n            name?.let {\n                where(table.name like it)\n            } \n            storeName?.let {\n                where(store.name like it) \n            }\n            storeWebsite?.let {\n                where(store.website like it)\n            }\n            select(table)\n        }\n        .execute()\n}\n")))),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If only ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," is specified, without ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite"),", then ",(0,l.kt)("inlineCode",{parentName:"p"},"store")," is a created but unused join object, thus ignored. The final generated SQL contains no joins."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere tb_1_.NAME = ?\n"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If ",(0,l.kt)("inlineCode",{parentName:"p"},"storeName")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"storeWebsite")," are specified, ",(0,l.kt)("inlineCode",{parentName:"p"},"store")," will be used, leading to join operations in the final generated SQL. This is obvious so no example here.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Solve the problem in scenario 2:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"List<Long> findDistinctIds(\n    @Nullable Long aId,\n    @Nullable Long bId,\n    @Nullable Long cId,\n    @Nullable Long dId,\n    @Nullable Long eId\n) {\n    ATable table = Tables.A_TABLE;\n\n    // Create JOIN objects unconditionally first,\n    // Not used join objects will be auto ignored,\n    // so no useless JOIN objects \n    // highlight-start\n    BTableEx b = table.asTableEx().bs();\n    CTableEx c = b.cs();\n    DTableEx d = c.ds();\n    ETableEx e = d.es();\n    // highlight-end\n\n    return sqlClient\n        .createQuery(table)\n        .whereIf(\n            aId != null,\n            () -> table.id().like(aId)\n        )\n        .whereIf(\n            bId != null,  \n            () -> b.id().like(bId)\n        )\n        .whereIf(\n            cId != null,\n            () -> c.id().like(cId)\n        )\n        .whereIf(\n            dId != null,\n            () -> d.id().like(dId)\n        )\n        .whereIf(\n            eId != null,\n            () -> e.id().like(eId)\n        )\n        .select(book.id())\n        .distinct()\n        .execute();\n}\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun findDistinctIds(\n    aId: Long? = null,\n    bId: Long? = null,\n    cId: Long? = null,\n    dId: Long? = null,\n    eId: Long? = null  \n): List<Long> {\n    \n    // Create JOIN object unconditionally first,\n    // will be auto ignored if not used later,\n    // so no useless JOIN\n    // highlight-start  \n    val b = table.asTableEx().bs\n    val c = b.cs\n    val d = c.ds\n    val e = d.es\n    // highlight-end\n\n    return sqlClient\n        .createQuery(A::class) {\n            aId?.let {\n                where(table.id eq it)\n            }\n            bId?.let {\n                where(b.id eq it)\n            }\n            cId?.let {\n                where(c.id eq it)  \n            }\n            dId?.let {\n                where(d.id eq it)\n            }\n            eId?.let {\n                where(e.id eq it)\n            }\n            select(table.id) \n        }\n        .distinct()\n        .execute()\n}\n")))),(0,l.kt)("admonition",{parentName:"li",type:"info"},(0,l.kt)("ul",{parentName:"admonition"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Given the basics above, no need to list the generated SQL for different parameter combinations here. Just understand that the final SQL will not contain useless joins.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},'When a JOIN object is used by the SQL DSL, it will be marked as "used" to prevent being ignored. This mark is transitive.'),(0,l.kt)("p",{parentName:"li"},"  For example: Marking ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),' as "used" will naturally also mark ',(0,l.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"table"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here (and various TableEx types in Java) is a concept to be introduced in later docs ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")))))))),(0,l.kt)("h2",{id:"phantom-joins"},"Phantom Joins"),(0,l.kt)("h3",{id:"two-ways-to-filter-on-associated-ids"},"Two ways to filter on associated ids"),(0,l.kt)("p",null,"For foreign key based associations, there are two ways to filter on the associated id:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Use the foreign key property directly"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        // highlight-next-line\n        .storeId()\n        .eq(2L)  \n    )\n    .select(book)\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            // highlight-next-line  \n            .storeId\n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{parentName:"li",type:"tip"},(0,l.kt)("p",{parentName:"admonition"},"For one-to-one/many-to-one associations",(0,l.kt)("br",{parentName:"p"}),"\n",(0,l.kt)("em",{parentName:"p"},"(like ",(0,l.kt)("inlineCode",{parentName:"em"},"Book.store")," in this example)"),",\neven if the user does not declare an ",(0,l.kt)("a",{parentName:"p",href:"../../mapping/advanced/view/id-view"},"@IdView"),(0,l.kt)("br",{parentName:"p"}),"\n","property for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," entity,\nthe ",(0,l.kt)("inlineCode",{parentName:"p"},"storeId")," property can still be used in SQL DSL."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Join to the associated object first, then access the id property"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .store()\n        // highlight-next-line\n        .id() // only access id\n        .eq(2L)\n    )\n    .select(book)  \n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .store\n            // highlight-next-line\n            .id // only access id\n            eq 2L  \n        )\n        select(table)\n    }\n    .execute()\n")))))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"These two approaches are not equivalent:"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where(table.storeId().eq(2L))"),": Simply filter based on the foreign key field of the current table.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where(table.store().id().eq(2L))"),": Actually join to the associated table first, then check the associated id value."))),(0,l.kt)("p",{parentName:"li"},"They are not equivalent because:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The foreign key may be fake, i.e. there is no corresponding foreign key constraint in the database. This will cause non-null pseudo foreign keys to be unable to fetch non-null associated objects through joining.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The associated object may be affected by ",(0,l.kt)("a",{parentName:"p",href:"../global-filter"},"global filters"),", so it should be ignored even if it exists in the database.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"However, the two approaches are completely equivalent ",(0,l.kt)("em",{parentName:"p"},"when all of the following conditions are met"),":"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The association is a one-to-one or many-to-one association based on foreign key, not through a join table or other reverse association mapping.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The foreign key is real, i.e. there is a corresponding foreign key constraint in the database. See ",(0,l.kt)("a",{parentName:"p",href:"../../mapping/base/foreignkey"},"Real and Fake Foreign Keys"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The associated object is not affected by ",(0,l.kt)("a",{parentName:"p",href:"../global-filter"},"global filters"),". Note this refers to either of:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter/user-filter"},"User-defined filters")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter/logical-deleted"},"Logical deletion filters"))))),(0,l.kt)("p",{parentName:"li"},"In this case, the id of the associated object is actually just the foreign key of the current table, so they are equivalent."))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Developers should understand the difference between these two approaches and choose the right one according to the business needs."),(0,l.kt)("p",{parentName:"admonition"},"However, when the two approaches are equivalent, optimizing the second approach into the first one is very beneficial - this is called phantom join elimination."),(0,l.kt)("p",{parentName:"admonition"},"The equivalence of the two query methods is a precondition for phantom join elimination to take effect, so this will not be repeated below.")),(0,l.kt)("h3",{id:"inapplicable-scenarios"},"Inapplicable Scenarios"),(0,l.kt)("p",null,"Phantom join elimination is only applicable to accessing the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property of associated objects, not other properties."),(0,l.kt)("p",null,"Here, accessing the ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," property of the associated object is used as an example to demonstrate the inability to eliminate the join."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(book.store().name().eq("MANNING")) \n    .select(book)\n    .execute();\n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val books = sqlClient\n    .createQuery(Book::class) {\n        where(table.store.name eq "MANNING")\n        select(table)\n    }\n    .execute()\n')))),(0,l.kt)("p",null,"The generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE, \n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\n    /* highlight-start */ \n    inner join BOOK_STORE as tb_2_\n        on tb_1_.STORE_ID = tb_2_.ID\n    /* highlight-end */\nwhere\n    tb_2_.NAME = ?\n")),(0,l.kt)("h3",{id:"applicable-scenarios"},"Applicable scenarios"),(0,l.kt)("p",null,"If only the id property of the associated object is accessed, phantom join elimination can be triggered. For example:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .store()\n        // highlight-next-line\n        .id() // Access id only\n        .eq(2L)\n    )\n    .select(book)\n    .execute(); \n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .store\n            // highlight-next-line\n            .id // Access id only\n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("p",null,"This time, the generated SQL: "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    tb_1_.ID,\n    tb_1_.NAME,\n    tb_1_.EDITION,\n    tb_1_.PRICE,\n    tb_1_.STORE_ID\nfrom BOOK as tb_1_\nwhere tb_1_.STORE_ID = ?  \n")),(0,l.kt)("p",null,"We see no table join in the SQL, only a condition ",(0,l.kt)("inlineCode",{parentName:"p"},"tb_1_.STORE_ID = ?")," based on the foreign key."),(0,l.kt)("p",null,"The reason: For a many-to-one association mapped by foreign key, the parent table's id is actually the child table's own foreign key. "),(0,l.kt)("h2",{id:"half-joins"},"Half Joins"),(0,l.kt)("p",null,"Half joins are a concept similar to phantom joins, but for join table based associations."),(0,l.kt)("h3",{id:"two-ways-to-filter-on-associated-ids-1"},"Two ways to filter on associated ids"),(0,l.kt)("p",null,"For join table based associations, there are two ways to filter on the associated id:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Check the foreign key field in the join table"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .asTableEx()\n        // highlight-next-line\n        .authorIds()\n        .eq(2L)\n    )\n    .select(book)\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .asTableEx()\n            // highlight-next-line\n            .authorIds\n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{parentName:"li",type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here has no substantial function, it will be introduced in\nthe next doc ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")),(0,l.kt)("admonition",{parentName:"li",type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"For one-to-many/many-to-many associations ",(0,l.kt)("em",{parentName:"p"},"(like ",(0,l.kt)("inlineCode",{parentName:"em"},"Book.authors")," in this example)"),",\n",(0,l.kt)("em",{parentName:"p"},"users must declare an ",(0,l.kt)("a",{parentName:"em",href:"../../mapping/advanced/view/id-view"},"@IdView")," property\n"),"for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Book")," entity to access the ",(0,l.kt)("inlineCode",{parentName:"p"},"authorIds")," property in SQL DSL."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Join to the associated object first, then access the id property"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Book> books = sqlClient\n    .createQuery(book)\n    .where(\n        book\n        .asTableEx()  \n        .authors()\n        // highlight-next-line\n        .id() // only access id\n        .eq(2L)\n    )\n    .select(book)\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val books = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n            .asTableEx()\n            .authors\n            // highlight-next-line\n            .id // only access id\n            eq 2L\n        )\n        select(table)\n    }\n    .execute()\n")))),(0,l.kt)("admonition",{parentName:"li",type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here has no substantial function, it will be introduced in\nthe next doc ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"These two approaches are not equivalent:"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where(table.authorIds().eq(2L))"),": 1 join operation"),(0,l.kt)("p",{parentName:"li"},"From the current table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK"),", join to ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING")," table and directly check the ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING.AUTHOR_ID")," field.")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"where(table.authors().id().eq(2L))"),": 2 join operations"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Based on current table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK"),", join to ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Based on join table ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING"),", join to ",(0,l.kt)("inlineCode",{parentName:"p"},"AUTHOR")))),(0,l.kt)("p",{parentName:"li"},"Finally, check the ",(0,l.kt)("inlineCode",{parentName:"p"},"AUTHOR.ID")," field."))),(0,l.kt)("p",{parentName:"li"},"They are not equivalent because:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The foreign key ",(0,l.kt)("inlineCode",{parentName:"p"},"BOOK_AUTHOR_MAPPING.AUTHOR_ID")," may be fake, i.e. there is no corresponding foreign key constraint in the database. This will cause non-null pseudo foreign keys to be unable to fetch non-null associated objects through joining.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The associated object may be affected by ",(0,l.kt)("a",{parentName:"p",href:"../global-filter"},"global filters"),", so it should be ignored even if it exists in the database.")))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"However, the two approaches are completely equivalent ",(0,l.kt)("em",{parentName:"p"},"when all of the following conditions are met"),":"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The foreign key in the join table is real, i.e. there is a corresponding foreign key constraint in the database. See ",(0,l.kt)("a",{parentName:"p",href:"../../mapping/base/foreignkey"},"Real and Fake Foreign Keys"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The associated object is not affected by ",(0,l.kt)("a",{parentName:"p",href:"../global-filter"},"global filters"),". Note this refers to either of:"),(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter/user-filter"},"User-defined filters")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"../global-filter/logical-deleted"},"Logical deletion filters"))))),(0,l.kt)("p",{parentName:"li"},"In this case, the id of the associated object is actually just the foreign key of the current table, so they are equivalent."))),(0,l.kt)("admonition",{type:"info"},(0,l.kt)("p",{parentName:"admonition"},"Developers should understand the difference between these two approaches and choose the right one according to the business needs.  "),(0,l.kt)("p",{parentName:"admonition"},"However, when the two approaches are equivalent, optimizing the second approach into the first one is very beneficial - this is called half join elimination."),(0,l.kt)("p",{parentName:"admonition"},"The equivalence of the two query methods is a precondition for half join elimination to take effect, so this will not be repeated below.  ")),(0,l.kt)("h3",{id:"inapplicable-scenarios-1"},"Inapplicable scenarios"),(0,l.kt)("p",null,"Half join elimination is only applicable to accessing the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," property of associated objects, not other properties."),(0,l.kt)("p",null,"Here, accessing the ",(0,l.kt)("inlineCode",{parentName:"p"},"Autor.firstName")," property of the associated object is used as an example to demonstrate the inability to eliminate the second join."),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'BookTable book = Tables.BOOK_TABLE;\n\nList<Long> bookIds = sqlClient  \n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            .firstName()\n            .eq("Alex") \n    )\n    .select(book.id())\n    .distinct()\n    .execute(); \n'))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},'val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx()\n                .authors\n                .firstName eq "Alex"\n        )\n        select(table.id)\n    }\n    .distinct() \n    .execute()\n')))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here has no substantial function, it will be introduced in\nthe next doc ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")),(0,l.kt)("p",null,"The generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_  \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID\ninner join AUTHOR as tb_3_ \n    on tb_2_.AUTHOR_ID = tb_3_.ID \n/* highlight-end */\nwhere tb_3_.FIRST_NAME = ?\n")),(0,l.kt)("p",null,"We see join tables produce two SQL JOIN clauses:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"First step: Join to intermediate table\n",(0,l.kt)("inlineCode",{parentName:"li"},"inner join BOOK_AUTHOR_MAPPING as tb_2_ on tb_1_.ID = tb_2_.BOOK_ID")),(0,l.kt)("li",{parentName:"ul"},"Second step: Join to target table\n",(0,l.kt)("inlineCode",{parentName:"li"},"inner join AUTHOR as tb_3_ on tb_2_.AUTHOR_ID = tb_3_.ID"))),(0,l.kt)("h3",{id:"applicable-scenarios-1"},"Applicable scenarios"),(0,l.kt)("p",null,"If only the id property of the associated object is accessed, half join elimination can be triggered. For example:"),(0,l.kt)(o.Z,{groupId:"language",mdxType:"Tabs"},(0,l.kt)(r.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"BookTable book = Tables.BOOK_TABLE;\n\nList<Long> bookIds = sqlClient\n    .createQuery(book)\n    .where(\n        book\n            .asTableEx()\n            .authors()\n            // highlight-next-line\n            .id() // Access id only\n            .eq(2L)\n    )\n    .select(book.id())\n    .distinct()\n    .execute();\n"))),(0,l.kt)(r.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin"},"val bookIds = sqlClient\n    .createQuery(Book::class) {\n        where(\n            table\n                .asTableEx()\n                .authors\n                // highlight-next-line\n                .id // Access id only\n                eq 2L\n        )\n        select(table.id) \n    }\n    .distinct()\n    .execute() \n")))),(0,l.kt)("admonition",{type:"note"},(0,l.kt)("p",{parentName:"admonition"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"asTableEx")," here has no substantial function, it will be introduced in\nthe next doc ",(0,l.kt)("a",{parentName:"p",href:"./table-ex"},"Pagination Safety"),". Please ignore it for now.")),(0,l.kt)("p",null,"This time, the generated SQL:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select\n    distinct tb_1_.ID\nfrom BOOK as tb_1_   \n/* highlight-start */\ninner join BOOK_AUTHOR_MAPPING as tb_2_\n    on tb_1_.ID = tb_2_.BOOK_ID  \n/* highlight-end */\nwhere tb_2_.AUTHOR_ID = ?\n")),(0,l.kt)("p",null,"This time we only see one SQL JOIN clause instead of two."),(0,l.kt)("p",null,"The reason: The target table's primary key is actually the foreign key from the intermediate table to the target table."))}k.isMDXComponent=!0}}]);