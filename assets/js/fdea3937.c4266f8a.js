"use strict";(self.webpackChunkdocusaurus_code=self.webpackChunkdocusaurus_code||[]).push([[669],{3905:(e,a,t)=>{t.d(a,{Zo:()=>s,kt:()=>u});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=n.createContext({}),d=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},s=function(e){var a=d(e.components);return n.createElement(p.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,v=m["".concat(p,".").concat(u)]||m[u]||c[u]||i;return t?n.createElement(v,l(l({ref:a},s),{},{components:t})):n.createElement(v,l({ref:a},s))}));function u(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var p in a)hasOwnProperty.call(a,p)&&(o[p]=a[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=t[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},85162:(e,a,t)=>{t.d(a,{Z:()=>l});var n=t(67294),r=t(34334);const i="tabItem_Ymn6";function l(e){let{children:a,hidden:t,className:l}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,l),hidden:t},a)}},65488:(e,a,t)=>{t.d(a,{Z:()=>u});var n=t(83117),r=t(67294),i=t(34334),l=t(72389),o=t(67392),p=t(7094),d=t(12466);const s="tabList__CuJ",c="tabItem_LNqP";function m(e){var a;const{lazy:t,block:l,defaultValue:m,values:u,groupId:v,className:g}=e,k=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),h=u??k.map((e=>{let{props:{value:a,label:t,attributes:n}}=e;return{value:a,label:t,attributes:n}})),b=(0,o.l)(h,((e,a)=>e.value===a.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const N=null===m?m:m??(null==(a=k.find((e=>e.props.default)))?void 0:a.props.value)??k[0].props.value;if(null!==N&&!h.some((e=>e.value===N)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${N}" but none of its children has the corresponding value. Available values are: ${h.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:S}=(0,p.U)(),[f,P]=(0,r.useState)(N),C=[],{blockElementScrollPositionUntilNextRender:T}=(0,d.o5)();if(null!=v){const e=y[v];null!=e&&e!==f&&h.some((a=>a.value===e))&&P(e)}const I=e=>{const a=e.currentTarget,t=C.indexOf(a),n=h[t].value;n!==f&&(T(a),P(n),null!=v&&S(v,String(n)))},U=e=>{var a;let t=null;switch(e.key){case"ArrowRight":{const a=C.indexOf(e.currentTarget)+1;t=C[a]??C[0];break}case"ArrowLeft":{const a=C.indexOf(e.currentTarget)-1;t=C[a]??C[C.length-1];break}}null==(a=t)||a.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",s)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":l},g)},h.map((e=>{let{value:a,label:t,attributes:l}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:f===a?0:-1,"aria-selected":f===a,key:a,ref:e=>C.push(e),onKeyDown:U,onFocus:I,onClick:I},l,{className:(0,i.Z)("tabs__item",c,null==l?void 0:l.className,{"tabs__item--active":f===a})}),t??a)}))),t?(0,r.cloneElement)(k.filter((e=>e.props.value===f))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},k.map(((e,a)=>(0,r.cloneElement)(e,{key:a,hidden:e.props.value!==f})))))}function u(e){const a=(0,l.Z)();return r.createElement(m,(0,n.Z)({key:String(a)},e))}},67172:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>p,default:()=>u,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var n=t(83117),r=(t(67294),t(3905)),i=t(65488),l=t(85162);const o={sidebar_position:10,title:"Scalar Provider"},p=void 0,d={unversionedId:"configuration/scala-provider",id:"configuration/scala-provider",title:"Scalar Provider",description:"Basic Concepts",source:"@site/docs/configuration/scala-provider.mdx",sourceDirName:"configuration",slug:"/configuration/scala-provider",permalink:"/jimmer-doc/docs/configuration/scala-provider",draft:!1,editUrl:"https://github.com/babyfish-ct/jimmer-doc/edit/main/docs/configuration/scala-provider.mdx",tags:[],version:"current",lastUpdatedAt:1731427770,formattedLastUpdatedAt:"Nov 12, 2024",sidebarPosition:10,frontMatter:{sidebar_position:10,title:"Scalar Provider"},sidebar:"tutorialSidebar",previous:{title:"Microservice",permalink:"/jimmer-doc/docs/configuration/micro-service"},next:{title:"Cache Abandoned Reason",permalink:"/jimmer-doc/docs/configuration/cache-abandoned"}},s={},c=[{value:"Basic Concepts",id:"basic-concepts",level:2},{value:"Global ScalarProvider",id:"global-scalarprovider",level:2},{value:"Define ScalarProvider",id:"define-scalarprovider",level:3},{value:"Register Scalar Provider",id:"register-scalar-provider",level:3},{value:"Property level ScalarProvider",id:"property-level-scalarprovider",level:2},{value:"Non-Spring registration",id:"non-spring-registration",level:3},{value:"Spring registration",id:"spring-registration",level:3}],m={toc:c};function u(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"basic-concepts"},"Basic Concepts"),(0,r.kt)("p",null,"In previous documents, we have introduced how to ",(0,r.kt)("a",{parentName:"p",href:"../mapping/advanced/enum"},"map enums"),", and how to use ",(0,r.kt)("inlineCode",{parentName:"p"},"@Serialized")," to ",(0,r.kt)("a",{parentName:"p",href:"../mapping/advanced/json"},"map JSON"),"."),(0,r.kt)("p",null,"However, sometimes neither of these methods can meet our requirements. In this case, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),"."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," is the most low-level SPI of Jimmer for custom data types. "),(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("a",{parentName:"p",href:"../mapping/advanced/enum"},"Enum Mapping")," and ",(0,r.kt)("a",{parentName:"p",href:"../mapping/advanced/json"},"JSON Mapping")," we discussed before are actually Jimmer's built-in implementations of ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),".")),(0,r.kt)("p",null,"Multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," can be registered for SqlClient. Each ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," tells Jimmer how to handle a custom data type."),(0,r.kt)("p",null,"There are two types of ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Global"),(0,r.kt)("p",{parentName:"li"},"Define the mapping rules between Java/Kotlin types and database types globally and uniformly. Any entity definition that contains properties of this type will be uniformly handled by the global ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),"."),(0,r.kt)("admonition",{parentName:"li",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Global ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," can only handle non-collection types, such as: classes, interfaces, enums, etc. It cannot handle collection types like: ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),", etc."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Property level"),(0,r.kt)("p",{parentName:"li"},"For a specific entity property, define the mapping rules between Java/Kotlin types and database types."),(0,r.kt)("admonition",{parentName:"li",type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," can handle any non-built-in types of Jimmer, including collection types such as: ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If the mapped property type is a collection type, the property needs to be annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"@org.babyfish.jimmer.Scalar"),".")))))),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@Serialized")," annotation discussed in ",(0,r.kt)("a",{parentName:"p",href:"../mapping/advanced/json"},"JSON Mapping")," can annotate both the return type of properties and entity properties. "),(0,r.kt)("p",{parentName:"admonition"},"This is because the more low-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," has two types.")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," is an SPI interface provided by Jimmer, which is defined as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="ScalarProvider"',title:'"ScalarProvider"'},"package org.babyfish.jimmer.sql.runtime;\n\nimport java.util.function.Consumer;\n\npublic abstract class ScalarProvider<T \u2776, S \u2777> {\n\n    protected ScalarProvider(Class<T> scalarType, Class<S> sqlType) { \u2778\n        ...Omitted code...\n    }\n\n    protected ScalarProvider() { \u2779\n        ...Omitted code...\n    }\n\n    public abstract T toScalar(S sqlValue); \u277a\n\n    public abstract S toSql(T scalarValue); \u277b\n\n    public Collection<ImmutableProp> getHandledProps() { \u277c\n        return null;\n    }\n }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2776 Generic parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),": Data type in Java/Kotlin;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2777 Generic parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),": Data type in the database; ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2778 Constructor that explicitly specifies the types represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),";"),(0,r.kt)("p",{parentName:"li"},"This constructor is usually used to define ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," with higher generality and reusability.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u2779 Constructor that does not need to explicitly specify the types represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),";"),(0,r.kt)("p",{parentName:"li"},"It requires derived classes to explicitly specify generic parameters ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"S")," so that Jimmer can automatically analyze the types represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"S"),". Otherwise, an exception will occur."),(0,r.kt)("p",{parentName:"li"},"This constructor is usually used to define ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," corresponding to specific types without requiring generality and reusability.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u277a Method ",(0,r.kt)("inlineCode",{parentName:"p"},"toScalar"),": Convert non-null data read from the database to Java data;")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u277b Method ",(0,r.kt)("inlineCode",{parentName:"p"},"toSql"),": Convert non-null Java data to data acceptable to the database; ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"\u277c If you want to define a property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),", one option ",(0,r.kt)("em",{parentName:"p"},"(there are other options)")," is to override the ",(0,r.kt)("inlineCode",{parentName:"p"},"getHandledProps")," method in the derived class;"))),(0,r.kt)("h2",{id:"global-scalarprovider"},"Global ScalarProvider"),(0,r.kt)("p",null,"For example, the current database does not support the UUID type, which can be handled as follows:"),(0,r.kt)("h3",{id:"define-scalarprovider"},"Define ScalarProvider"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="UUIDScalarProvider.java"',title:'"UUIDScalarProvider.java"'},"public class UUIDScalarProvider extends AbstractScalarProvider<UUID, String> {\n\n    @Override\n    public UUID toScalar(String sqlValue) {\n        return UUID.fromString(sqlValue);\n    }\n\n    @Override\n    public String toSql(UUID scalarValue) {\n        return scalarValue.toString();\n    }\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="UUIDScalarProvider.kt"',title:'"UUIDScalarProvider.kt"'},"class UUIDScalarProvider : ScalarProvider<UUID, String> {\n\n    override fun toScalar(sqlValue: String): UUID =\n        UUID.fromString(sqlValue)\n\n    override fun toSql(scalarValue: UUID): String =\n        scalarValue.toString()\n}\n")))),(0,r.kt)("h3",{id:"register-scalar-provider"},"Register Scalar Provider"),(0,r.kt)("p",null,"There are two ways for Jimmer to register ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use Spring Boot Starter"),(0,r.kt)("p",{parentName:"li"},"Just let the derived classes of ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," be managed by Spring. There are two options:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Modify the above ",(0,r.kt)("inlineCode",{parentName:"p"},"UUIDScalarProvider")," class and annotate it with spring's ",(0,r.kt)("inlineCode",{parentName:"p"},"@Component")),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="UUIDScalarProvider.java"',title:'"UUIDScalarProvider.java"'},"// highlight-next-line\n@Component \npublic class UUIDScalarProvider extends AbstractScalarProvider<UUID, String> {\n        \n    ...Omitted code...\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="UUIDScalarProvider.kt"',title:'"UUIDScalarProvider.kt"'},"// highlight-next-line\n@Component\nclass UUIDScalarProvider : ScalarProvider<UUID, String> {\n\n    ...Omitted code...\n}\n"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use Spring's ",(0,r.kt)("inlineCode",{parentName:"p"},"@Bean")," method to register the UUIDScalaProvider object to Spring"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// highlight-next-line\n@Bean\npublic UUIDScalarProvider uuidScalarProvider() {\n    return new UUIDScalarProvider();\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"// highlight-next-line\n@Bean \nfun uuidScalarProvider(): UUIDScalarProvider =\n    UnitTestIdGenerator()\n"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use underlying API"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient() {\n    return JSqlClient\n        .newBuilder()\n        // highlight-next-line\n        .addScalarProvider(new UUIDScalarProvider())\n        ...Omit other configurations...\n        .build();\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient() : KSqlClient =  \n    newKSqlClient {\n        // highlight-next-line\n        addScalarProvider(UUIDScalarProvider())\n        ...Omit other configurations...\n    }\n")))))),(0,r.kt)("h2",{id:"property-level-scalarprovider"},"Property level ScalarProvider"),(0,r.kt)("p",null,"The only difference between property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," and global ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," is that it only applies to specific properties, not all properties."),(0,r.kt)("p",null,"So the most important data conversion methods ",(0,r.kt)("inlineCode",{parentName:"p"},"toScalar")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"toSql")," in property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," have exactly the same user code implementation, only the registration method is different."),(0,r.kt)("p",null,"Therefore, here we assume there is a user-defined type ",(0,r.kt)("inlineCode",{parentName:"p"},"Location")," and its corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," implementation class is ",(0,r.kt)("inlineCode",{parentName:"p"},"LocationScalarProvider"),". Specific implementation is omitted."),(0,r.kt)("h3",{id:"non-spring-registration"},"Non-Spring registration"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Bean\npublic JSqlClient sqlClient() {\n  return JSqlClient\n      .newBuilder()\n      .setScalarProvider(\n          // highlight-next-line\n          FlightProps.SOURCE_LOCATION\n          new LocationScalarProvider() \n      )\n      .setScalarProvider(\n          // highlight-next-line  \n          FlightProps.TARGET_LOCATION\n          new LocationScalarProvider()\n      )\n      ...Omit other configurations...\n      .build();\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"@Bean\nfun sqlClient() : KSqlClient =\n  newKSqlClient {\n      setScalarProvider(\n          // highlight-next-line\n          Flight::sourceLocation\n          LocationScalarProvider()\n      )\n      setScalarProvider(\n          // highlight-next-line\n          Flight::targetLocation\n          LocationScalarProvider()\n      )\n      ...Omit other configurations...\n  }\n")))),(0,r.kt)("p",null,"That is, except for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Flight.sourceLocation")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Flight.targetLocation")," properties, ",(0,r.kt)("inlineCode",{parentName:"p"},"LocationScalarProvider")," does not affect any other properties of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Location"),"."),(0,r.kt)("h3",{id:"spring-registration"},"Spring registration"),(0,r.kt)("p",null,"The above method is intuitive, but it is manually registered. Can Spring's automatic registration method be used to register property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),"?"),(0,r.kt)("p",null,"Of course. Just override the ",(0,r.kt)("inlineCode",{parentName:"p"},"getHandledProps")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),", and you can use the method of registering global ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider")," to register property-level ",(0,r.kt)("inlineCode",{parentName:"p"},"ScalarProvider"),". For example:"),(0,r.kt)(i.Z,{groupId:"language",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="LocationScalarProvider.java"',title:'"LocationScalarProvider.java"'},"@Component\npublic class LocationScalarProvider extends AbstractScalarProvider<Location, String> {\n    \n    @Override\n    // highlight-next-line \n    public Collection<ImmutableProp> getHandledProps() {\n        return Arrays.asList(\n            FlightProps.SOURCE_LOCATION,\n            FlightProps.TARGET_LOCATION\n        );\n    }\n\n    ...Omit other code...\n}\n"))),(0,r.kt)(l.Z,{value:"kotlin",label:"Kotlin",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="LocationScalarProvider.kt"',title:'"LocationScalarProvider.kt"'},"@Component \nclass LocationScalarProvider : ScalarProvider<Location, String> {\n\n    // highlight-next-line\n    override fun getHandledProps(): Collection<ImmutableProp> =\n        listOf(\n            Flight::sourceLocation.toImmutableProp(),\n            Flight::targetLocation.toImmutableProp()\n        )\n\n    ...Omit other code...\n}\n")))))}u.isMDXComponent=!0}}]);